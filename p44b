#!/bin/bash
# p44b: host script for managing OpenWrt based product builds

# Helpers
err()
{
  echo -e "$_ERR$@$_N"
}

warn()
{
  echo -e "$_WARN$@$_N"
}

notice()
{
  echo -e "$_NOTICE$@$_N"
}

info()
{
  echo -e "$_INFO$@$_N"
}

plain()
{
  echo -e "$_N$@"
}


die() {
  err "*** Error:" $@
  exit 1
}


starting() {
  notice "=== starting" $@ "at $(date +%Y-%m-%d_%H:%M:%S)"
}

finished() {
  if [[ "$?" == "0" ]]; then
    notice "=== succeeded" $@ "at $(date +%Y-%m-%d_%H:%M:%S)"
    return 0
  else
    err "=== failed" $@ "at $(date +%Y-%m-%d_%H:%M:%S)"
    return 1
  fi
}

syntax() {
  # calling function
  CMD="${FUNCNAME[1]##command:}"
  err "Syntax error:" $@
  help:$CMD
  exit 1
}


has() {
  # eg. has command update
  local kind=$1
  local name=$2
  type -t $kind:$name | grep -q function
}


# colorisation
if [ -t 1 ]; then
  if [ -z "$NO_COLOR" ]; then
    _INFO='\033[90m' # info: gray (bright black)
    _NOTICE='\033[92m' # notice: bright green
    _ERR='\033[91m' # error: bright red
    _WARN='\033[93m' # warning: bright yellow
    _N='\033[m' # normal
  fi
fi

# need extglob matching
shopt -s extglob

# must always be started from buildroot
BUILDROOT="$(pwd -P)"
if [ ! -f "${BUILDROOT}/feeds.conf.default" ]; then
  error "${BUILDROOT} does not contain a feeds.conf.default -> not an openwrt buildroot"
  die "Must be started from a openwrt buildroot"
fi

# the alias name to be used for referring to the script
ALIAS="p44b"

# defaults
if [ -z ${P44B_IMAGETYPE+x} ]; then
  P44B_IMAGETYPE="squashfs-sysupgrade"
fi

# actual script location and file
SCRIPTDIR="$(dirname $0)"
pushd ${SCRIPTDIR} >/dev/null
SCRIPTDIR="$(pwd -P)"
popd >/dev/null
SCRIPTNAME="$(basename $0)"
SCRIPTFILE="${SCRIPTDIR}/${SCRIPTNAME}"

# derived
P44B_STATE_DIR="${BUILDROOT}/.p44build"

# from state, if existing
if [ -f "${P44B_STATE_DIR}/p44b_src_dir" ]; then
  P44B_SRC_DIR=$(cat "${P44B_STATE_DIR}/p44b_src_dir")
  if [ ! -d "${P44B_SRC_DIR}" ]; then
    warn "Warning: ${ALIAS} source dir does not exist: '${P44B_SRC_DIR}'"
    P44B_SRC_DIR=
  fi
fi
if [ -f "${P44B_STATE_DIR}/target_id" ]; then
  TARGET_ID=$(cat "${P44B_STATE_DIR}/target_id")
fi
# well-known subdirs of P44B_SRC_DIR
CONFIGS_DIR="configs"
TRACKING_DIR="tracking"
SCRIPTS_DIR="scripts"
GLOBAL_PATCHES_DIR="global-patches"

read_config()
{
  pushd ${BUILDROOT} >/dev/null
  # import .config:
  if [[ $# -eq 0 ]]; then
    local DOT_CONFIG_LOCATION="${P44B_SRC_DIR}/${CONFIGS_DIR}/.config-${TARGET_ID}"
  else
    if [[ "${1:0:1}" != "/" ]]; then
      local DOT_CONFIG_LOCATION="${BUILDROOT}/$1"
    else
      local DOT_CONFIG_LOCATION="$1"
    fi
  fi
  source "${DOT_CONFIG_LOCATION}" 2>/dev/null
  # define derived vars
  VERSION_TAG="${CONFIG_VERSION_NUMBER}"
  if [ ! -z "${CONFIG_P44_FEED_NAME}" ]; then
    VERSION_TAG="${CONFIG_P44_FEED_NAME}/${VERSION_TAG}"
  fi
  VERSION_TAG="${CONFIG_VERSION_PRODUCT}/${VERSION_TAG}/${TARGET_ID}"
  # musl suffix
  MUSL_SUFFIX=""
  if [[ "${CONFIG_TARGET_SUFFIX#muslgnu}" == "eabi" ]]; then
    MUSL_SUFFIX="_eabi"
  fi
  LIBCID="${CONFIG_LIBC}"
  if [ ! -z "${CONFIG_LIBC_VERSION}" ]; then
    LIBCID="${LIBCID}-${CONFIG_LIBC_VERSION}${MUSL_SUFFIX}"
  else
    LIBCID="${LIBCID}${MUSL_SUFFIX}"
  fi
  # target/toolchain identifying string
  TARGETID="target-${CONFIG_ARCH}_${CONFIG_CPU_TYPE}_${LIBCID}"
  TOOLCHAINID="toolchain-${CONFIG_ARCH}_${CONFIG_CPU_TYPE}_gcc-${CONFIG_GCC_VERSION}_${LIBCID}"
  # build dir
  BUILD_DIR="${BUILDROOT}/build_dir/${TARGETID}"
  # toolchain root
  TOOLCHAIN_ROOT="${BUILDROOT}/build_dir/${TOOLCHAINID}"
  # staging root
  STAGING_ROOT="${BUILDROOT}/staging_dir/${TARGETID}/root-${CONFIG_TARGET_BOARD}"
  # target bin dir
  TARGET_BIN="${BUILDROOT}/bin/targets/${CONFIG_TARGET_BOARD}/${CONFIG_TARGET_SUBTARGET}"
  # architecture bin dir
  ARCH_BIN="${BUILDROOT}/bin/packages/${CONFIG_TARGET_ARCH_PACKAGES}"
  # dist name
  IMG_DIST_NAME="${CONFIG_VERSION_DIST}"
  IMG_DIST_NAME_LC=$(echo "$IMG_DIST_NAME" | awk '{print tolower($0)}')
  popd >/dev/null
}


set_script_env()
{
  # publish some environment variables for called scripts
  # - most recently built image
  read_config ".config" # current settings, not saved ones
  local SRCIMGS=$(ls -1t ${TARGET_BIN}/${IMG_DIST_NAME_LC}-${CONFIG_VERSION_NUMBER}*-${CONFIG_TARGET_BOARD}-${CONFIG_TARGET_SUBTARGET}-${CONFIG_TARGET_PROFILE##DEVICE_}-${P44B_IMAGETYPE}* 2>/dev/null);
  if [[ $? -eq 0 ]]; then
    set -- $SRCIMGS
    export BUILT_IMAGE=$1
  fi
  # - also publish some dirs with P44B_ prefix for convenience in called scripts/commands
  export BUILDROOT
  export P44B_IMAGETYPE
  export P44B_SRC_DIR
  export P44B_CONFIGS_DIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
  export P44B_TRACKING_DIR="${P44B_SRC_DIR}/${TRACKING_DIR}"
  export P44B_SCRIPTS_DIR="${P44B_SRC_DIR}/${SCRIPTS_DIR}"
  export P44B_GLOBAL_PATCHES_DIR="${P44B_SRC_DIR}/${GLOBAL_PATCHES_DIR}"
}


# echo "SCRIPTDIR=$SCRIPTDIR"
# echo "SCRIPTNAME=$SCRIPTNAME"
# echo "SCRIPTFILE=$SCRIPTFILE"
# echo "P44B_STATE_DIR=$P44B_STATE_DIR"
# echo "P44B_SRC_DIR=$P44B_SRC_DIR"
#
# exit 0


help:new() {
cat >&2 <<ENDHELP
Usage: [<path/to/script>]${SCRIPTNAME} ${FUNCNAME[0]##help:} <path to new p44build directory to create>

Create a new p44build directory with minimal/template files for managing a openwrt project

Does the following
- creates the specified directory and standard subdirectories as the p44build directory
- creates some standard global-patches needed for p44b operation
- creates dummy/example scripts for build/package/deploy/flash commands
- creates a template for tracking packages (tracked_packages)
- saves the current openwrt version as buildroot_checkout marker (using git describe)
- saves a diffconfig of the current openwrt .config as a default target config

ENDHELP
}
command:new() {
  local NEW_P44B_DIR="$1"
  if [[ $# -ne 1 ]]; then
    syntax "must specify a path where to create new p44build directory"
  fi
  if [ -e "${NEW_P44B_DIR}" ]; then
    die "'${NEW_P44B_DIR}' already exists"
  fi
  notice "creating new p44build default setup in ${NEW_P44B_DIR}"
  # create and enter new p44build directory
  info "creating new p44build dir"
  if ! mkdir "${NEW_P44B_DIR}"; then
    die "cannot create ${NEW_P44B_DIR}"
  fi
  pushd "${NEW_P44B_DIR}" >/dev/null
  mkdir "${CONFIGS_DIR}"
  mkdir "${SCRIPTS_DIR}"
  mkdir "${GLOBAL_PATCHES_DIR}"
  # create standard global patches
  info "creating standard global patch to .gitignore p44b temprorary dirs/files in openwrt tree"
  cat >"$GLOBAL_PATCHES_DIR/001-gitignore.diff" <<'ENDPATCH'
--- a/.gitignore
+++ b/.gitignore
@@ -12,7 +12,7 @@
 /logs
 /feeds
 /feeds.conf
-/files
+#/files
 /overlay
 /package/feeds
 /package/openwrt-packages
@@ -29,3 +29,8 @@ git-src
 .project
 .cproject
 .ccache
+# p44build additions
+/patches
+/.pc
+/.p44build
+p44b
ENDPATCH
  info "creating standard global patch to save git checkout markers in build dirs"
  cat >"$GLOBAL_PATCHES_DIR/002-download-save-gitrev.diff" <<'ENDPATCH'
--- a/include/download.mk
+++ b/include/download.mk
@@ -205,7 +205,10 @@ define DownloadMethod/rawgit
 	[ \! -d $(SUBDIR) ] && \
 	git clone $(OPTS) $(URL) $(SUBDIR) && \
 	(cd $(SUBDIR) && git checkout $(VERSION) && \
-	git submodule update --init --recursive) && \
+	git submodule update --init --recursive && \
+	echo "$(URL)" >.gitdownload_url && \
+	echo "$(VERSION)" >.gitdownload_version && \
+	git rev-parse HEAD >.gitdownload_rev) && \
 	echo "Packing checkout..." && \
 	export TAR_TIMESTAMP=`cd $(SUBDIR) && git log -1 --format='@%ct'` && \
 	rm -rf $(SUBDIR)/.git && \
ENDPATCH
  # create tracking templates
  info "creating tracked_packages template"
  cat >"tracked_packages" <<'ENDTRACK'
# Specify packages for which git revision SHA/name should be recorded with each p44b save
# One package per line in the form: feedname/packagename, e.g. (without the #):
#plan44/serialfwd
ENDTRACK
  # create script templates
  info "creating script templates/examples for custom build/package/deploy/flash operations"
  cat >"$SCRIPTS_DIR/build.sh" <<'ENDSCRIPT'
# Speed up make world
echo "Note: using all but one of the available processors/cores for building"
make -j$(($(nproc)-1))
ENDSCRIPT
  cat >"$SCRIPTS_DIR/package.sh" <<'ENDSCRIPT'
# here you could perform steps to package (e.g. sign, rename, compress etc.) a built image
# The BUILT_IMAGE environment variable is set to the full path of the most recently built image
echo "No implementation for packaging"
exit 1
ENDSCRIPT
  cat >"$SCRIPTS_DIR/deploy.sh" <<'ENDSCRIPT'
# here you could perform steps to deploy a built image (e.g. transfer it to a web server)
# The BUILT_IMAGE environment variable is set to the full path of the most recently built image
echo "No implementation for deploying"
exit 1
ENDSCRIPT
  cat >"$SCRIPTS_DIR/flash.sh" <<'ENDSCRIPT'
# here you could perform steps to flash a target with the freshly built image
# The BUILT_IMAGE environment variable is set to the full path of the most recently built image
echo "No implementation for flashing"
exit 1
ENDSCRIPT
  cat >"$SCRIPTS_DIR/buildprep.inc" <<'ENDSCRIPT'
# Here you can set environment variables and perform other preparation steps for a 'buildtargets' run.
# This file is sourced into the buildtargets run. If it does not return success, buildtargets is aborted.

# Example: when running commitversion, make sure not only changes in the p44build dir, but also
#   in the enclosing dir (which is usually the "umbrella" openwrt package for the project) are committed,
#   so stage these in advance now:
#pushd ${P44B_SRC_DIR}/..  >/dev/null
#git add .
#popd  >/dev/null

# Example: get a user input needed for building and store it in a environment variable
#   for a buildtargets step, for example a passphrase for a signing key etc.
#if [ -z "${NEEDEDVAR}" ]; then
#  read -s -p "Need a user input: " NEEDEDVAR; echo
#  export NEEDEDVAR
#fi
ENDSCRIPT
  popd >/dev/null
  # now back in dir from where we've been called (usually: openwrt buildroot)
  if [[ -f ".config" ]]; then
    # we are in a openwrt buildroot
    # - save current openwrt checkout
    local BUILDROOT_CHECKOUT=$(git describe HEAD)
    info "recording current Openwrt checkout (${BUILDROOT_CHECKOUT}) in buildroot_checkout file"
    echo "${BUILDROOT_CHECKOUT}" >"${NEW_P44B_DIR}/buildroot_checkout"
    # - save current openwrt (diff)config
    local TARGET_ID=$(sed -n -E -e 's/CONFIG_TARGET_PROFILE="DEVICE_([^"]*)"/\1/p' .config)
    info "saving diffconfig of current openwrt .config as default target config named ${TARGET_ID}"
    ./scripts/diffconfig.sh >"${NEW_P44B_DIR}/${CONFIGS_DIR}/diffconfig-${TARGET_ID}"
    cp .config "${NEW_P44B_DIR}/${CONFIGS_DIR}/.config-${TARGET_ID}"
  else
    warn "current directory does not seem to be a openwrt buildroot -> cannot save checkout/create default target"
  fi
  # done
  notice "done creating p44build default setup in ${NEW_P44B_DIR}"
  info "to start working with this you might want to run:"
  plain "  ${ALIAS} cleanup # to revert tree changes from current p44b project, if any"
  plain "  ${ALIAS} init ${NEW_P44B_DIR} # to start using the new project"
  plain "  ${ALIAS} prepare # to apply the patches"
  plain "  ${ALIAS} target ${TARGET_ID} # to apply the target config"
  return 0
}


help:init() {
cat >&2 <<ENDHELP
Usage: [<path/to/script>]${SCRIPTNAME} ${FUNCNAME[0]##help:} <path to p44build source directory of a product>

Initialize a buildroot tree for p44b operation

Does the following
- put a softlink called "$ALIAS" pointing to the script itself into buildroot
  (to allow easy calling with just ./${ALIAS})
- creates a .p44build directory in the buildroot
- remembers the product's p44build source directory in .p44build/p44b_src_dir
- sets a softlink to the P44B_SRC dir

ENDHELP
}
command:init() {
  local NEW_P44B_DIR="$1"
  if [[ $# -ne 1 ]]; then
    syntax "must specify a path to a p44build directory"
  fi
  if [ ! -d "${NEW_P44B_DIR}" ]; then
    die "'${NEW_P44B_DIR}' is not a directory"
  fi
  # create state directory
  if [ -e "${P44B_STATE_DIR}" ]; then
    die "p44build apparently already initialized - if not, please cleanup first"
  fi
  mkdir "${P44B_STATE_DIR}"
  # expand and save the directory
  pushd "${NEW_P44B_DIR}" >/dev/null
  P44B_SRC_DIR="$(pwd -P)"
  popd >/dev/null
  echo -n "${P44B_SRC_DIR}" > "${P44B_STATE_DIR}/p44b_src_dir"
  # find patches directory
  local PATCHES_DIR="${GLOBAL_PATCHES_DIR}"
  if [ ! -d "${P44B_SRC_DIR}/${PATCHES_DIR}" ]; then
    # fall back to old name
    PATCHES_DIR="lede-patches"
  fi
  # create soft link into buildroot to patch dir within sources
  if [ -f "${BUILDROOT}/patches" ]; then
    die "non-softlink '${BUILDROOT}/patches' already exists"
  fi
  ln -sfh "${P44B_SRC_DIR}/${PATCHES_DIR}" "${BUILDROOT}/patches"
  # create convenience soft link to script itself in buildroot (but do not replace regular file, should there be one)
  if [ ! -f "${BUILDROOT}/${ALIAS}" ]; then
    ln -sfh "${SCRIPTFILE}" "${BUILDROOT}/${ALIAS}"
  fi
  # check for matching tracking info and warn if there are differences
  local CURRENT=$(git rev-parse HEAD)
  local SAVED=$(cat "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA")
  if [[ "${CURRENT}" != "${SAVED}" ]]; then
    warn "*** Warning: last buildroot saved was '${SAVED}', but is now at '${CURRENT}'"
    warn "    MOST PROBABLY, feeds.conf needs to be updated and"
    warn "    ./scripts/feeds update <feednames> should be applied!"
    info "=== Diff between distribution's (recommended) feeds.conf.default and current feeds.conf"
    diff feeds.conf.default feeds.conf;
    info "=== end diff"
  fi
  info "=== Diff between last saved feeds.conf snapshot and current feeds.conf"
  if ! diff ${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot feeds.conf; then
    warn "*** Warning: current feeds.conf differs from snapshot -> maybe root was updated?"
  fi
  info "=== end diff"
  notice "Successfully initialized p44build using directory: ${P44B_SRC_DIR}"
  return 0
}


help:switch() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} <path to p44build source directory of a product>

Switch to a different p44b directory without re-patching the buildroot tree.
This is only possible if the two p44b directories share the same tree checkout SHA
and the same set of patches in ${GLOBAL_PATCHES_DIR}

This makes switching between very similar projects faster, as keeping the patches in place
prevents triggering expensive rebuilds.

ENDHELP
}
command:switch() {
  local NEW_P44B_DIR="$1"
  if [[ $# -ne 1 ]]; then
    syntax "must specify a path to a p44build directory"
  fi
  if [ ! -d "${NEW_P44B_DIR}" ]; then
    die "'${NEW_P44B_DIR}' is not a directory"
  fi
  # state directory must exist
  if [ ! -e "${P44B_STATE_DIR}" ]; then
    die "p44build apparently not initialized, cannot switch - use 'init' first"
  fi
  # expand new name
  pushd "${NEW_P44B_DIR}" >/dev/null
  NEW_P44B_DIR="$(pwd -P)"
  popd >/dev/null
  # check for same openwrt tree state
  local OLD_CHECKOUT=$(cat "${P44B_SRC_DIR}/buildroot_checkout")
  local NEW_CHECKOUT=$(cat "${NEW_P44B_DIR}/buildroot_checkout")
  if [[ "${OLD_CHECKOUT}" != "${NEW_CHECKOUT}" ]]; then
    die "to-be-switched to directory is based on different buildroot checkout ('${NEW_CHECKOUT}' rather than '${OLD_CHECKOUT}') - use 'cleanup'/'init'"
  fi
  # clean feeds from MacOS folder state files (there could be some in the patches, too)
  find ${BUILDROOT}/feeds -name .DS_Store -delete
  # check for same set of global patches (note: no check for legacy "lede-patches" here!)
  local OLD_PATCHES="${P44B_SRC_DIR}/${GLOBAL_PATCHES_DIR}"
  local NEW_PATCHES="${NEW_P44B_DIR}/${GLOBAL_PATCHES_DIR}"
  if ! diff "${OLD_PATCHES}" "${NEW_PATCHES}"; then
    die "global set of patches is not equal, cannot switch - use 'cleanup'/'init'"
  fi
  # make sure patches is a softlink
  if [ ! -h "${BUILDROOT}/patches" ]; then
    die "Error: '${BUILDROOT}/patches' is not a softlink!"
  fi
#   echo "patches dirs are equal: $OLD_PATCHES <-> $NEW_PATCHES"
#   echo "P44B_STATE_DIR = $P44B_STATE_DIR"
#   echo "NEW_P44B_DIR = $NEW_P44B_DIR"
#   echo "BUILDROOT = $BUILDROOT"
#   return 1
  # switch is possible
  # - un-target
  rm "${P44B_STATE_DIR}/target_id" 2>/dev/null
  rm "${BUILDROOT}/.config"  2>/dev/null
  # - save the new p44build directory
  echo -n "${NEW_P44B_DIR}" > "${P44B_STATE_DIR}/p44b_src_dir"
  # - set the soft link in buildroot to the new (but identical) patch dir
  ln -sfh "${NEW_P44B_DIR}/${GLOBAL_PATCHES_DIR}" "${BUILDROOT}/patches"
  notice "Successfully switched to new p44build directory: ${NEW_P44B_DIR}"
  return 0
}


help:cleanup() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:}

cleans up all changes made by init/prepare to the openwrt tree

In particular:
- the project specific .config is removed
- all patches applied to the tree (with ${SCRIPTNAME} prepare) are removed
  (this is done with quilt pop -af in the buildroot)
- p44b specific softlinks and state is removed

Note: if state is not clean, the command will warn, but not reset the git checkout
  (only recommend it)

ENDHELP
}
command:cleanup() {
  if [[ $# -ne 0 ]]; then
    syntax "no argument expected"
  fi
  # Cleanup buildroot
  # - remove project specific config
  rm "${BUILDROOT}/.config" 2>/dev/null
  # - make sure patches are removed
  pushd "${BUILDROOT}" >/dev/null
  quilt pop -af
  # - remove the quilt working dir
  rm -rf "${BUILDROOT}/.pc"
  # - remove the softlink to the actual patches (but only softlink!)
  if [ -h "${BUILDROOT}/patches" ]; then
    rm "${BUILDROOT}/patches"
  fi
  # - remove the p44build state dir
  if [ -d "${P44B_STATE_DIR}" ]; then
    rm -rf "${P44B_STATE_DIR}"
  fi
  git status
  info "# if status is not clean, you might want to use..."
  plain "git reset --hard"
  info "# ...here to bring the tree back into clean state"
  popd >/dev/null
  # Note: do not remove the convenience link (will be updated in case another version of the script is used explicitly)
  return 0
}


help:prepare() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:}

Prepares (patches) the buildroot tree with project specific patches from ${GLOBAL_PATCHES_DIR}

In particular:
- removes current patches
- discards previous changes to the tree (if some are present, these will be stashed first)
- checks if buildroot checkoutr is as recorded in $P44B_SRC_DIR/buildroot_checkout
- applies all buildroot patches
- cleans feeds/ directory from macOS .DS_Store files which can interfere with builds

ENDHELP
}
# Prepare the tree
command:prepare() {
  if [[ $# -ne 0 ]]; then
    syntax "no argument expected"
  fi
  # checkout the buildroot checkout
  if [ -f "${P44B_SRC_DIR}/buildroot_checkout" ]; then
    local BUILDROOT_CHECKOUT=$(cat "${P44B_SRC_DIR}/buildroot_checkout")
    pushd ${BUILDROOT} >/dev/null
    # check current checkout
    # - sha-wise
    if git rev-parse HEAD | grep -q ${BUILDROOT_CHECKOUT}; then
      # SHA matches
      info "At correct SHA according to buildroot_checkout: ${BUILDROOT_CHECKOUT}"
    elif git log -n1 --oneline --decorate=short HEAD | grep -q ${BUILDROOT_CHECKOUT}; then
      # ref (branch, tag) matches
      info "At correct ref according to buildroot_checkout: ${BUILDROOT_CHECKOUT}"
    else
      err "Error: buildroot must be at ${BUILDROOT_CHECKOUT}"
      info "might want to use:"
      plain "  git checkout ${BUILDROOT_CHECKOUT}"
      return 1
    fi
    # remove patches that might be there
    quilt pop -af
    # stash just in case, to avoid loosing data
    git stash
    # switch to correct buildroot state
    git reset --hard
    # apply the patches
    if ! quilt push -a; then
	    err "Error: applying global patches not completely successful"
	    info "(just use quilt manually to review, fix and apply all remaining patches to complete the 'prepare' operation)"
    fi
    # clean feeds from MacOS folder state files
    find ${BUILDROOT}/feeds -name .DS_Store -delete
    # set flag
    touch "${P44B_STATE_DIR}/prepared"
  else
    err "Error: no buildroot_checkout"
    info "(might want to use ${TRACKING_DIR}/buildroot_SHA or ${TRACKING_DIR}/buildroot_VERS)"
    exit 1
  fi
}


help:instpkg() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:}

Installs all packages that were present at last ${SCRIPTNAME} save
(this is done by executing ${TRACKING_DIR}/install_packages.sh)

ENDHELP
}
command:instpkg() {
  # checkout the buildroot checkout
  if [ -f "${P44B_SRC_DIR}/${TRACKING_DIR}/install_packages.sh" ]; then
    bash ${P44B_SRC_DIR}/${TRACKING_DIR}/install_packages.sh
  else
    warn "Warning: no install_packages.sh found."
    info "You might want to install all packages instead with"
    plain "./scripts/feeds install -a"
  fi
}



help:target() {
cat >&2 <<ENDHELP
Usage:
  ${SCRIPTNAME} ${FUNCNAME[0]##help:}              - list all targets
  ${SCRIPTNAME} ${FUNCNAME[0]##help:} <target>     - configure for specified target

Applies configuration for the specified target to the buildroot from diffconfig saved
for the target (in ${CONFIGS_DIR}/diffconfig-<target>)

In particular:
- updates the package indices
- expands the saved diffconfig to a full .config (make defconfig)

ENDHELP
}
command:target() {
  if [ ! -f "${P44B_STATE_DIR}/prepared" ]; then
    die "buildroot is not yet prepared (global patches not applied) -> use ${SCRIPTNAME} prepare"
  fi
  if [[ $# -eq 0 ]]; then
    # list targets
    TARGETS="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig"*
    notice "Available targets:"
    for TG in ${TARGETS}; do
      plain "- ${TG##*/diffconfig-}"
    done
    return 0
  fi
  if [[ $# -ne 1 ]]; then
    syntax "specify single target"
  fi
  local NEW_TARGET_ID="$1"
  local DIFFCONFIG="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig-${NEW_TARGET_ID}"
  if [ ! -f "${DIFFCONFIG}" ]; then
    die "buildroot configuration file '${DIFFCONFIG}' not found"
  fi
  # remember the target identifier
  TARGET_ID="${NEW_TARGET_ID}"
  echo -n "${TARGET_ID}" > "${P44B_STATE_DIR}/target_id"
  # update the package indices
  info "Updating package indices"
  rm -rf ${BUILDROOT}/tmp 2>/dev/null
  pushd ${BUILDROOT} >/dev/null
  ./scripts/feeds update -i
  # copy the config and expand
  info "Expanding diffconfig-${NEW_TARGET_ID} into full .config"
  cp "${DIFFCONFIG}" "${BUILDROOT}/.config"
  make defconfig
  popd >/dev/null
  # show the status
  command:status
}



help:restore() {
cat >&2 <<ENDHELP
Usage:
  ${SCRIPTNAME} ${FUNCNAME[0]##help:} [--apply] <restore operations>

Restore operations are:
  root     : checkout the saved buildroot tree version (never automatically, not even with --apply)
  feeds    : checkout the saved feed versions
  packages : modify makefiles of tracked packages to point at the specific version in use at last save
  target   : apply diffconfig (as with ${SCRIPTNAME} target)

Options:
  --apply  : actually perform the restore (without --apply, needed changes are displayed only)
  --sha    : use exact SHA for buildroot, package feeds and tracked packages (rather than references/tags/branches)

ENDHELP
}
command:restore() {
  if [[ $# -lt 1 ]]; then
    syntax "need to specify what to restore"
  fi
  local BYSHA=0
  local APPLY=0
  local DO_ROOT=0
  local DO_FEEDS=0
  local DO_PACKAGES=0
  local DO_TARGET=0
  for OPT in $@ ; do
    case "$OPT" in
      "--sha") BYSHA=1;;
      "--apply") APPLY=1;;
      "root") DO_ROOT=1;;
      "feeds") DO_FEEDS=1;;
      "packages") DO_PACKAGES=1;;
      "target") DO_TARGET=1;;
      *) die "unknown option $OPT";;
    esac
  done
  if [[ -z "${TARGET_ID}" || -z "${P44B_SRC_DIR}" ]]; then
    die "No target selected, cannot restore"
  fi
  # diffconfig for current target
  local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
  # check if buildroot matches
  if [[ ${DO_ROOT} -ne 0 ]]; then
    pushd "${BUILDROOT}" >/dev/null
    local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
    if [[ ${BYSHA} -ne 0 ]]; then
      local CURRENT=$(git rev-parse HEAD)
      local SAVED=$(cat "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA")
    else
      local CURRENT=$(git rev-parse --abbrev-ref HEAD)
      local SAVED=$(cat "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_VERS")
    fi
    if [[ "${CURRENT}" != "${SAVED}" ]]; then
      warn "Buildroot originally saved from was at '${SAVED}', but is now at '${CURRENT}'"
      if [[ ${APPLY} -ne 0 ]]; then
        die "Cannot continue, please manually checkout the correct buildroot commit"
      fi
    fi
    notice "Buildroot state is correct: '${CURRENT}'"
    # current feeds.conf
    if ! cmp -s "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot" feeds.conf; then
      if [[ ${APPLY} -ne 0 ]]; then
        warn "feeds.conf has changed: moving original to feeds.conf_ORIG and putting new one in place"
        mv feeds.conf "feeds.conf_ORIG_$(date +%Y-%m-%d_%H:%M:%S)"
        cp "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot" feeds.conf
        info "Updating and reindexing feeds"
        ./scripts/feeds update
      else
        warn "feeds.conf has changed:"
        diff "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot" feeds.conf
        plain ""
      fi
    else
      info "feeds.conf is unchanged"
    fi
    popd >/dev/null
  fi
  # check feed states
  if [[ ${DO_FEEDS} -ne 0 ]]; then
    if [[ ${BYSHA} -ne 0 ]]; then
      local FEEDSTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_SHA"
    else
      local FEEDSTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_VERS"
    fi
    while IFS='' read -r line || [[ -n "$line" ]]; do
      if [[ "${line:0:1}" != "#" ]]; then
        local FEED="${line/ *}"
        local spec="${line:((${#FEED}+1))}"
        local URL="${spec%:*}"
        local SAVED="${spec:((${#URL}+1))}"
        pushd "${BUILDROOT}/feeds/${FEED}" >/dev/null
        if [[ ${BYSHA} -ne 0 ]]; then
          local CURRENT=$(git rev-parse HEAD)
        else
          local CURRENT=$(git rev-parse --abbrev-ref HEAD)
        fi
        popd >/dev/null
        if [[ "${CURRENT}" != "${SAVED}" ]]; then
          if [[ ${APPLY} -ne 0 ]]; then
            notice "restoring feed '${FEED}' checkout from current '${CURRENT}' to saved '${SAVED}'"
            pushd "${BUILDROOT}/feeds/${FEED}"; git stash; git checkout ${SAVED}; popd
          else
            warn "***** feed ${FEED} should be at '${SAVED}' but is at '${CURRENT}'"
            info "You might want to checkout the correct version:"
            plain "pushd ${BUILDROOT}/feeds/${FEED}; git stash; git checkout ${SAVED}; popd"
          fi
        fi
      fi
    done < "${FEEDSTATES}"
  fi
  # modify makefiles of tracked packages to point to saved versions
  if [[ ${DO_PACKAGES} -ne 0 ]]; then
    if [[ ${BYSHA} -ne 0 ]]; then
      local PACKAGESTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
    else
      local PACKAGESTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
    fi
    while IFS='' read -r line || [[ -n "$line" ]]; do
      if [[ "${line:0:1}" != "#" ]]; then
        local pspec="${line/ *}"
        local FEED="${pspec/\/*}"
        local PNAME="${pspec:((${#FEED}+1))}"
        local spec="${line:((${#pspec}+1))}"
        local URL="${spec%:*}"
        local SAVED="${spec:((${#URL}+1))}"
        #echo "FEED=${FEED}, PNAME=${PNAME}, URL=${URL}, SAVED=${SAVED}"
        pushd "${BUILDROOT}/feeds/${FEED}/${PNAME}" >/dev/null
        local mfn="Makefile_ORIG_$(date +%Y-%m-%d_%H:%M:%S)"
        sed -E \
         -e "/PKG_SOURCE_URL:=/s|PKG_SOURCE_URL:=(.*)$|PKG_SOURCE_URL:=${URL}|" \
         -e "/PKG_SOURCE_VERSION:=/s|PKG_SOURCE_VERSION:=(.*)$|PKG_SOURCE_VERSION:=${SAVED}|" \
         Makefile > "/tmp/${mfn}"
        if cmp -s Makefile "/tmp/${mfn}"; then
          info "${FEED}/${PNAME}: Makefile unchanged"
        else
          if [[ ${APPLY} -ne 0 ]]; then
            notice "${FEED}/${PNAME}: Makefile updated: PKG_SOURCE_URL='${URL}', PKG_SOURCE_VERSION='${SAVED}' - original: ${mfn}"
            mv Makefile "${mfn}"
            cp "/tmp/${mfn}" Makefile
          else
            warn "${FEED}/${PNAME}: Makefile needs to update: PKG_SOURCE_URL='${URL}', PKG_SOURCE_VERSION='${SAVED}'"
            diff Makefile "/tmp/${mfn}"
            plain ""
          fi
          rm "/tmp/${mfn}"
        fi
        popd >/dev/null
      fi
    done < "${PACKAGESTATES}"
  fi
  # target config re-apply
  if [[ ${DO_TARGET} -ne 0 ]]; then
    pushd "${BUILDROOT}" >/dev/null
    local cfn=".config_ORIG_$(date +%Y-%m-%d_%H:%M:%S)"
    if [[ ${APPLY} -ne 0 ]]; then
      notice "Re-applying target config, original version in ${cfn}"
      cp .config "${cfn}"
      command:target "${TARGET_ID}"
    else
      ./scripts/diffconfig.sh >"/tmp/diffconfig_${TARGET_ID}"
      warn "Target diffconfig has changed, should re-apply target settings:"
      diff "/tmp/diffconfig_${TARGET_ID}" "${CONFIGDIR}/diffconfig-${TARGET_ID}"
      plain ""
    fi
    popd >/dev/null
  fi
}



help:save() {
cat >&2 <<ENDHELP
Usage:
  ${SCRIPTNAME} ${FUNCNAME[0]##help:} [options]

Saves the current build state into the p44build/${TRACKING_DIR}. See options
for the items that can be saved. Specifying no options saves all items.

Options:
  -b, --buildroot : save buildroot state (SHA + symbolic rev)
  -c, --config    : save config & diffconfig for current target, feeds.conf
  -p, --packages  : save script to re-install all packages in use
  -f, --feeds     : save state (SHA + symbolic rev) of all feeds
  -t, --track     : track source git SHA + symbolic rev of packages listed in
                    tracked_packages, create ${TRACKING_DIR}/pushtags.sh

Committing these saved items to the project's feed repository captures all
information to reproduce this particular build later.

${SCRIPTNAME} restore can be used to re-establish a saved state later.

ENDHELP
}
command:save() {
  local SAVECONFIG=0
  local SAVEBUILDROOT=0
  local SAVEINSTPKG=0
  local SAVEFEEDS=0
  local SAVETRACK=0
  while [[ "${1:0:1}" == "-" ]]; do
    case "$1" in
      "-b"|"--buildroot") SAVEBUILDROOT=1;shift 1;;
      "-c"|"--config") SAVECONFIG=1;shift 1;;
      "-p"|"--packages") SAVEINSTPKG=1;shift 1;;
      "-f"|"--feeds") SAVEFEEDS=1;shift 1;;
      "-t"|"--track") SAVETRACK=1;shift 1;;
      *) syntax "unknown option $1";;
    esac
  done
  if [[ ${SAVEBUILDROOT} -eq 0 && ${SAVECONFIG} -eq 0 && ${SAVEINSTPKG} -eq 0 && ${SAVEFEEDS} -eq 0 && ${SAVETRACK} -eq 0  ]]; then
    SAVEBUILDROOT=1
    SAVECONFIG=1
    SAVEINSTPKG=1
    SAVEFEEDS=1
    SAVETRACK=1
  fi
  if [[ $# -ne 0 ]]; then
    syntax "no arguments expected"
  fi
  if [[ -z "${TARGET_ID}" || -z "${P44B_SRC_DIR}" ]]; then
    die "No target selected, cannot save"
  fi
  # Preparation we always need:
  starting "saving build state"
  pushd ${BUILDROOT} >/dev/null
  # - clean feeds from MacOS folder state files
  find ${BUILDROOT}/feeds -name .DS_Store -delete
  # - make sure we have the tracking dir
  mkdir "${P44B_SRC_DIR}/${TRACKING_DIR}" 2>/dev/null
  # Now the different steps
  if [[ ${SAVEBUILDROOT} -eq 1 ]]; then
    # SHA and branch of buildroot
    info "=== saving current buildroot state (SHA/rev)"
    local GITREV=$(git rev-parse HEAD)
    local GITVERS=$(git rev-parse --abbrev-ref HEAD)
    plain "openwrt buildroot: built from ${GITVERS} (SHA:${GITREV})"
    echo "${GITREV}" >"${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA"
    echo "${GITVERS}" >"${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_VERS"
  fi
  if [[ ${SAVECONFIG} -eq 1 ]]; then
    # current feeds.conf
    info "=== saving .config-${TARGET_ID} and diffconfig-${TARGET_ID} into ${CONFIGS_DIR}"
    cp feeds.conf "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot"
    # diffconfig for current target
    local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
    ./scripts/diffconfig.sh >"${CONFIGDIR}/diffconfig-${TARGET_ID}"
    # complete config for reference purposes
    cp .config "${CONFIGDIR}/.config-${TARGET_ID}"
  fi
  popd >/dev/null
  if [[ ${SAVEINSTPKG} -eq 1 ]]; then
    # Capture installed packages from feeds (as a script that can be run to update feeds and install the packages)
    info "=== saving installed packages into ${TRACKING_DIR}/install_packages.sh"
    local INSTPKGS="${P44B_SRC_DIR}/${TRACKING_DIR}/install_packages.sh"
    echo "# Run this script to install all packages that were installed at the time of p44b save" >"${INSTPKGS}"
    FEEDS=$(find ${BUILDROOT}/package/feeds -type d -depth 1 -exec "echo" "{}" ";")
    for FEED in ${FEEDS}; do
      FEEDNAME=$(basename ${FEED})
      #echo "--- feed=${FEEDNAME} dir=${FEED}"
      pushd ${FEED} >/dev/null
      echo "./scripts/feeds update ${FEEDNAME}" >>"${INSTPKGS}"
      for INSTPDIR in *; do
        #echo "---   instpdir=${INSTPDIR}"
        local CMNT=""
        local INSTPNAMES=$(sed -E -n -e "/^Source-Makefile: +feeds\/${FEEDNAME}.*\/${INSTPDIR}\/Makefile/,/^Source-Makefile:/s/^Package: +([-a-zA-Z_]+)/\1/p" ${BUILDROOT}/feeds/${FEEDNAME}.index)
        for INSTPNAME in ${INSTPNAMES}; do
          #echo "---     instpname=${INSTPNAME}"
          echo "${CMNT}./scripts/feeds install -p ${FEEDNAME} ${INSTPNAME}" >>"${INSTPKGS}"
          # installing one of the packages from a makefile is sufficient, show but comment out the other packages made available as well
          CMNT="#"
        done
      done
      popd >/dev/null
    done
  fi
  if [[ ${SAVEFEEDS} -eq 1 ]]; then
    # Capture state of feeds
    info "=== saving feed states"
    plain "# feed giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_VERS"
    plain "# feed giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_SHA"
    pushd "${BUILDROOT}/feeds" >/dev/null
    for FEED in !(*.*) ; do
      pushd "${FEED}" >/dev/null
      local GITURL=$(git remote show origin | sed -ne "/Fetch URL:/s/ *Fetch URL: //p")
      local GITREV=$(git rev-parse HEAD)
      local GITVERS=$(git rev-parse --abbrev-ref HEAD)
      plain "feed ${FEED}: origin at ${GITURL}:${GITVERS} (SHA:${GITREV})"
      echo "${FEED} ${GITURL}:${GITVERS}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_VERS"
      echo "${FEED} ${GITURL}:${GITREV}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_SHA"
      popd >/dev/null
    done
    popd >/dev/null
  fi
  if [[ ${SAVETRACK} -eq 1 ]]; then
    # Track package source SHAs/versions
    info "=== saving tracked package states"
    read_config
    # go through tracked packages
    local TRACKEDPACKAGES="${P44B_SRC_DIR}/tracked_packages"
    if [ ! -f "${TRACKEDPACKAGES}" ]; then
      notice "no tracked_packages file -> nothing to track"
      return 0
    fi
    # remove the previous trackings
    echo "# feed/package giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
    echo "# feed/package giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
    local PUSHTAGS="${P44B_SRC_DIR}/${TRACKING_DIR}/pushtags.sh"
    echo "#!/bin/bash" >"${PUSHTAGS}"
    echo "pushd /tmp >/dev/null; rm -rf /tmp/p44b_temp; mkdir p44b_temp; cd p44b_temp" >>"${PUSHTAGS}"
    while IFS='' read -r PSPEC || [[ -n "$PSPEC" ]]; do
      if [[ "${PSPEC:0:1}" == "#" || -z "$PSPEC" ]]; then
        continue
      fi
      local FEEDNAME=${PSPEC%%/*}
      local PKGNAME=${PSPEC#*/}
      #echo "feed=$FEEDNAME pgk=$PKGNAME"
      local PKGDIR="${BUILDROOT}/feeds/${FEEDNAME}/${PKGNAME}"
      if [ ! -d "${PKGDIR}" ]; then
        warn "*** package not found for ${PSPEC}"
      else
        #echo "packagedir=$PKGDIR"
        # collect info from feed
        local PKG_NAME=$(sed -n -e "/^PKG_NAME:=/s/PKG_NAME:=//p" "${PKGDIR}/Makefile")
        local PKG_VERSION=$(sed -n -e "/^PKG_VERSION:=/s/PKG_VERSION:=//p" "${PKGDIR}/Makefile")
        local PKG_SOURCE_URL=$(sed -n -e "/^PKG_SOURCE_URL:=/s/PKG_SOURCE_URL:=//p" "${PKGDIR}/Makefile")
        local PKG_SOURCE_VERSION=$(sed -n -e "/^PKG_SOURCE_VERSION:=/s/PKG_SOURCE_VERSION:=//p" "${PKGDIR}/Makefile")
        local PKGNAMEVERS="${PKG_NAME}-${PKG_VERSION}"
        # build-dir as defined in makefile
        local PD=$(sed -n -e "/^PKG_BUILD_DIR:=/s/PKG_BUILD_DIR:=//p" "${PKGDIR}/Makefile")
        local PD=${PD//\$\(/\$\{}
        local PD=${PD//\)/\}}
        eval PKGBUILDDIR="$PD"
        #echo "PKG_NAME=$PKG_NAME, PKG_VERSION=$PKG_VERSION, PKG_SOURCE_VERSION=$PKG_SOURCE_VERSION, PD=$PD"
        #echo "package build dir: ${PKGBUILDDIR}"
        # collect info from build
        if [ ! -d "${PKGBUILDDIR}" ]; then
          warn "*** ${PKGNAMEVERS}: no build directory found"
        elif [ ! -e "${PKGBUILDDIR}/.gitdownload_url" ]; then
          warn "*** ${PKGNAMEVERS}: was not built with p44b checkout revision tracking"
        else
          # get info recorded during build
          local BUILDURL=$(cat "${PKGBUILDDIR}/.gitdownload_url")
          local BUILDREV=$(cat "${PKGBUILDDIR}/.gitdownload_rev")
          local BUILDVERS=$(cat "${PKGBUILDDIR}/.gitdownload_version")
          # get info from source repo
          if [[ "${BUILDREV}" != "${BUILDVERS}" && "${PKG_SOURCE_VERSION}" != "${BUILDREV}" ]]; then
            # vers is a ref (branch, tag) that can move -> get the SHA of that ref from the git source repo
            local R=$(git ls-remote "${PKG_SOURCE_URL}" "${PKG_SOURCE_VERSION}")
            local GITREV="${R%%[[:blank:]]*}"
            local GITVERS="${PKG_SOURCE_VERSION}"
          else
            # vers is a SHA that cannot move, so no need to check with source repo
            local GITREV="${BUILDREV}"
            local GITVERS=
          fi
          # consistency checks
          if [[ "${BUILDVERS}" != "${PKG_SOURCE_VERSION}" && "${BUILDREV}" != "${PKG_SOURCE_VERSION}" ]]; then
            warn "*** ${PKGNAMEVERS}: branch/commit recorded in build (${BUILDVERS}) differs from PKG_SOURCE_VERSION (${PKG_SOURCE_VERSION})"
          elif [[ "${PKG_SOURCE_URL}" != "${BUILDURL}" ]]; then
            warn "*** ${PKGNAMEVERS}: URL recorded in build (${BUILDURL}) differs from PKG_SOURCE_URL (${PKG_SOURCE_URL})"
          else
            # basic checks ok
            plain "package ${PKGNAMEVERS}: was built from ${BUILDURL}:${BUILDVERS} (SHA:${BUILDREV})"
            # check if we can trust the GITVERS branch name actually pointing to the built commit
            if [[ "${GITREV}" != "${BUILDREV}" ]]; then
              warn "*** ${PKGNAMEVERS}: Warning: SHA recorded in build (${BUILDREV}) differs from 'git ls-remote ... ${PKG_SOURCE_VERSION}' (${GITREV})"
              echo "# ${PSPEC}: build SHA differs from current 'git ls-remote ... ${PKG_SOURCE_VERSION}' (${GITREV}) - could be due to commits happening since build" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
              echo "# ${PSPEC}: WARNING: There is no branch/tag currently at ${BUILDREV}. We need to checkout whole repo" >>"${PUSHTAGS}"
              GITVERS=
            fi
            # - record fixed sha source
            echo "${PSPEC} ${BUILDURL}:${BUILDREV}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
            # - record version/branch source
            echo "${PSPEC} ${BUILDURL}:${BUILDVERS}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
            # - create entry for tagging source repositories in tagging script
            if [[ ${PKG_SOURCE_URL:0:4} == "http" ]]; then
              warn "*** ${PKGNAMEVERS}: source URL is http(s), cannot be pushed to -> do not create tagging commands"
              echo "# ${PKGNAMEVERS}: cannot push to http URL ${PKG_SOURCE_URL} -> cannot tag original" >>"${PUSHTAGS}"
            else
              echo "# ${PKGNAMEVERS}: clone, tag and push back to original repo at ${PKG_SOURCE_URL}" >>"${PUSHTAGS}"
              if [[ -n "${GITVERS}" ]]; then
                echo "git clone --depth 1 --no-checkout --single-branch --branch ${BUILDVERS} ${PKG_SOURCE_URL} ${PKG_NAME}" >>"${PUSHTAGS}"
              else
                # we do not know which branch we need, just clone normally in full depth
                echo "git clone --no-checkout ${PKG_SOURCE_URL} ${PKG_NAME}" >>"${PUSHTAGS}"
              fi
              echo "pushd ${PKG_NAME}" >>"${PUSHTAGS}"
              echo "git tag -f ${VERSION_TAG} ${BUILDREV}" >>"${PUSHTAGS}"
              echo "git push -f origin ${VERSION_TAG}" >>"${PUSHTAGS}"
              echo "popd" >>"${PUSHTAGS}"
            fi
          fi
        fi
      fi
    done < "${TRACKEDPACKAGES}"
    chmod a+x "${PUSHTAGS}"
    echo "popd >/dev/null" >>"${PUSHTAGS}"
  fi
  finished "saving build state"
}


help:commitversion() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} [-f|--freeze]

Create a commit in the feed repository containing the current p44build directory
containing the currently saved state with a commit named after current version information in .config

If --freeze is specified, the currently recorded SHA for tracked packages will be inserted into
the package makefile's PKG_SOURCE_VERSION before committing, staged for commit and then immediately
reverted to original. This assumes tracked packages are in the same git/feed as the p44build dir.

The commit message is composed from .config's
- CONFIG_VERSION_PRODUCT
- CONFIG_VERSION_NUMBER
- (optionally)CONFIG_P44_FEED_NAME
- target ID (as set with ${SCRIPTNAME} target

ENDHELP
}
command:commitversion() {
  local DO_FREEZE_VERS=0
  for OPT in $@ ; do
    case "$OPT" in
      "-f"|"--freeze") DO_FREEZE_VERS=1;;
      *) die "unknown option $OPT";;
    esac
  done
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    die "Nothing saved, cannot commit"
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    die ".config does not contain version information"
  fi
  # clean feeds from MacOS folder state files
  find ${BUILDROOT}/feeds -name .DS_Store -delete
  # optionally modify package makefiles and set PKG_SOURCE_VERSION to SHA
  if [[ ${DO_FREEZE_VERS} -ne 0 ]]; then
    local PACKAGESTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
    while IFS='' read -r line || [[ -n "$line" ]]; do
      if [[ "${line:0:1}" != "#" ]]; then
        local pspec="${line/ *}"
        local FEED="${pspec/\/*}"
        local PNAME="${pspec:((${#FEED}+1))}"
        local spec="${line:((${#pspec}+1))}"
        local URL="${spec%:*}"
        local SAVED="${spec:((${#URL}+1))}"
        #echo "FEED=${FEED}, PNAME=${PNAME}, URL=${URL}, SAVED=${SAVED}"
        pushd "${BUILDROOT}/feeds/${FEED}/${PNAME}" >/dev/null
        if [[ -f Makefile && -n "${FEED}" && -n "${PNAME}" && -n "${SAVED}" ]]; then
          sed -i ".ORIG" -E -e "/PKG_SOURCE_VERSION:=/s|PKG_SOURCE_VERSION:=(.*)$|PKG_SOURCE_VERSION:=${SAVED}|" Makefile
          # stage changed version
          git add Makefile
          info "Staged Makefile of ${FEED}/${PNAME} with frozen PKG_SOURCE_VERSION:=${SAVED}"
          # and restore original right away
          mv -f Makefile.ORIG Makefile
        else
          err "Package ${FEED}/${PNAME} Makefile not found"
        fi
        popd >/dev/null
      fi
    done < "${PACKAGESTATES}"
  fi
  # now actually commit
  pushd "${P44B_SRC_DIR}" >/dev/null
  git add -A "${P44B_SRC_DIR}"
  git commit -m "${VERSION_TAG}"
  popd >/dev/null
  notice "# You might want to amend this commit with changes outside the ${ALIAS} directory"
}



help:tagversion() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} [-p|--packages]

Tag the current commit in the feed repository containing the current p44build directory

If --packages is specified, ${TRACKING_DIR}/pushtags.sh is also executed (which
is a script created at ${SCRIPTNAME} save, containing commands to clone a temporary
checkout of each of the tracked packages, create a tag and push the tag to the
origin repository. This is useful to tag a project-essential package with the
same tag as the overall OS version it is used in.

The tag is composed from .config's
- CONFIG_VERSION_PRODUCT
- CONFIG_VERSION_NUMBER
- (optionally)CONFIG_P44_FEED_NAME
- target ID (as set with ${SCRIPTNAME} target

ENDHELP
}
command:tagversion() {
  local DO_TAG_PKGS=0
  for OPT in $@ ; do
    case "$OPT" in
      "-p"|"--packages") DO_TAG_PKGS=1;;
      *) die "unknown option $OPT";;
    esac
  done
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    die "Nothing saved, cannot tag"
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    die ".config does not contain version information"
  else
    notice "Tagging: ${VERSION_TAG}"
    pushd "${P44B_SRC_DIR}" >/dev/null
    git tag -f "${VERSION_TAG}"
    popd >/dev/null
    # tag tracked packages?
    if [[ ${DO_TAG_PKGS} -ne 0 ]]; then
      info "# Tagging tracked packages (with writable source repos) now:"
      ${P44B_SRC_DIR}/${TRACKING_DIR}/pushtags.sh
      info "# Done tagging tracked packages"
    fi
  fi
}


help:pushversion() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} <remote>

Push the current head of feed repository containing the current p44build directory
and the current version tag (if any) to the specified remote.

ENDHELP
}
# push the current feed's master and the version tag to origin
command:pushversion() {
  if [[ $# -ne 1 ]]; then
    syntax "specifiy git remote for pushing"
  fi
  local REMOTE="$1"
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    die "Nothing saved, cannot push"
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    die ".config does not contain version information"
  else
    # detect branch
    pushd "${P44B_SRC_DIR}" >/dev/null
    local BRANCH=$(git rev-parse --abbrev-ref HEAD)
    notice "Pushing branch '${BRANCH}' and tag '${VERSION_TAG}' -> remote '${REMOTE}'"
    git push ${REMOTE} ${BRANCH}
    git push ${REMOTE} -f "${VERSION_TAG}"
    popd >/dev/null
  fi
}


# display status
help:status() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} status

Displays various status information

ENDHELP
}
command:status() {
  if [[ $# -ne 0 ]]; then
    syntax "no arguments expected"
  fi
  if [ ! -z "${P44B_SRC_DIR}" ]; then
    notice "Initialized with ${ALIAS} sources at '${P44B_SRC_DIR}'"
    read_config ".config" # current settings, not saved ones
    if [ ! -f "${P44B_STATE_DIR}/prepared" ]; then
      warn "buildroot is not yet prepared -> use ${SCRIPTNAME} prepare"
    elif [[ -z "${TARGET_ID}" || -z "${P44B_SRC_DIR}" ]]; then
      warn "No target selected -> use ${SCRIPTNAME} target"
    else
      info "Target"
      echo "- Current target  : '${TARGET_ID}'"
      echo "- Distribution    : ${CONFIG_VERSION_DIST}"
      echo "- Product         : ${CONFIG_VERSION_PRODUCT}"
      echo "- HW Revision     : ${CONFIG_VERSION_HWREV}"
      echo "- board/target    : ${CONFIG_TARGET_BOARD} / ${CONFIG_TARGET_SUBTARGET} / ${CONFIG_TARGET_PROFILE}"
      echo "- version tag     : ${VERSION_TAG}"
      echo "- package arch    : ${CONFIG_TARGET_ARCH_PACKAGES}"
      echo "- target host     : ${TARGET_HOST}"
      info "Directories"
      echo "- toolchain       : ${TOOLCHAIN_ROOT}"
      echo "- Build dir       : ${BUILD_DIR}"
      echo "- staging_dir     : ${STAGING_ROOT}"
      echo "- target bin dir  : ${TARGET_BIN}"
      echo "- arch bin dir    : ${ARCH_BIN}"
      info "Current version (configured in .config)"
      echo "- Current version : ${CONFIG_VERSION_NUMBER}"
      echo "- Current feed    : ${CONFIG_P44_FEED_NAME}"
      read_config # saved settings
      info "Version of last saved .config (${CONFIGS_DIR}/.config-${TARGET_ID})"
      echo "- Saved Version   : ${CONFIG_VERSION_NUMBER}"
      echo "- Saved feed      : ${CONFIG_P44_FEED_NAME}"
      read_config "${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig-${TARGET_ID}" # prepared diffconfig settings
      info "Version as set in ${CONFIGS_DIR}/diffconfig-${TARGET_ID}"
      echo "- Next Version    : ${CONFIG_VERSION_NUMBER}"
      echo "- Next feed       : ${CONFIG_P44_FEED_NAME}"
    fi
  else
    die "This tree is not initialized for ${ALIAS} yet"
  fi
}


help:build() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} [<optional args for build.sh or make>]

If present, calls the build.sh script in the p44build/${SCRIPTS_DIR}
otherwise, just calls "make" at the buildroot level

ENDHELP
}
command:build() {
  starting "build"
  local BUILDCMD="${P44B_SRC_DIR}/${SCRIPTS_DIR}/build.sh"
  if [ ! -f "${BUILDCMD}" ]; then
    info "no build.sh script in ${ALIAS} folder -> just using make"
    BUILDCMD="make"
  fi
  # run build script/make
  set_script_env
  info $BUILDCMD "$@"
  $BUILDCMD "$@"
  finished "build"
}


help:flash() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} [<optional args flash.sh>]

calls the flash.sh script in the p44build/${SCRIPTS_DIR}

Note: the BUILT_IMAGE environment variable is set to the full path of the most
  recently built image for the current target

ENDHELP
}
command:flash() {
  local FLASHSCRIPT="${P44B_SRC_DIR}/${SCRIPTS_DIR}/flash.sh"
  if [ ! -x "${FLASHSCRIPT}" ]; then
    die "no executable flash.sh script in ${ALIAS} folder"
  fi
  # run it
  set_script_env
  starting "flashing"
  info $FLASHSCRIPT "$@"
  $FLASHSCRIPT "$@"
  finished "flashing"
}


help:package() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} [<optional args package.sh>]

calls the package.sh script in the p44build/${SCRIPTS_DIR}

Note: the BUILT_IMAGE environment variable is set to the full path of the most
  recently built image for the current target

ENDHELP
}
command:package() {
  local PKGSCRIPT="${P44B_SRC_DIR}/${SCRIPTS_DIR}/package.sh"
  if [ ! -x "${PKGSCRIPT}" ]; then
    die "no executable package.sh script in ${ALIAS} script folder"
  fi
  # run it
  set_script_env
  starting "packaging"
  info $PKGSCRIPT "$@"
  $PKGSCRIPT "$@"
  finished "packaging"
}


help:deploy() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} [<optional args deploy.sh>]

calls the deploy.sh script in the p44build/${SCRIPTS_DIR}

Note: the BUILT_IMAGE environment variable is set to the full path of the most
  recently built image for the current target

ENDHELP
}
command:deploy() {
  local DPLSCRIPT="${P44B_SRC_DIR}/${SCRIPTS_DIR}/deploy.sh"
  if [ ! -x "${DPLSCRIPT}" ]; then
    die "no executable deploy.sh script in ${ALIAS} script folder"
  fi
  # run it
  set_script_env
  starting "deploy"
  info $DPLSCRIPT "$@"
  $DPLSCRIPT "$@"
  finished "deploy"
}



help:buildtargets() {
cat >&2 <<ENDHELP
Usage:
  ${SCRIPTNAME} ${FUNCNAME[0]##help:}                      - list available targets
  ${SCRIPTNAME} ${FUNCNAME[0]##help:} [opts] <targets>...  - build/package/save one or multiple targets
Options:
  -t, --tag    : execute 'commitversion' and 'tagversion' subcommands after build and save
  -p, --push   : execute 'pushversion' subcommand after build and save
  -d, --deploy : execute 'deploy' subcommand after build and save

Switches to, builds, packages, saves and optionally commits and tags, pushes and deploys the listed <targets>

Note:
  - "ALL" can be specified instead of target names to build all targets
  - if existing, p44build/${SCRIPTS_DIR}/buildprep.inc is sourced into the script before
    starting building, allowing to set extra environment variables for the subsequent steps

ENDHELP
}
command:buildtargets() {
  local DO_TAG=0
  local DO_PUSH=0
  local DO_DEPLOY=0
  local TARGETS
  for ARG in $@ ; do
    case "$ARG" in
      "-t"|"--tag") DO_TAG=1;;
      "-d"|"--deploy") DO_DEPLOY=1;;
      "-p"|"--push") DO_PUSH=1;;
      "all") local TGS="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig"*; for TG in ${TGS}; do TARGETS="$TARGETS ${TG##*/diffconfig-}"; done;;
      *) TARGETS="$TARGETS $ARG";;
    esac
  done
  # sanity check
  if [ -z "${TARGETS}" ]; then
    # list targets
    TARGETS="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig"*
    notice "Available targets (specify 'ALL' to build all):"
    for TG in ${TARGETS}; do
      echo "- ${TG##*/diffconfig-}"
    done
    return 0
  fi
  # check for "ALL"
  if [[ "${TARGETS}" == " ALL" ]]; then
    TARGETS=
    for TG in "${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig"*; do
      TARGETS="$TARGETS ${TG##*/diffconfig-}"
    done
  fi
  # source preparation script, if any
  local PREPINC="${P44B_SRC_DIR}/${SCRIPTS_DIR}/buildprep.inc"
  if [ -x "${PREPINC}" ]; then
    # source it to set ennvironment vars etc.
    source "${PREPINC}"
    if [ $? -ne 0 ]; then die "${SCRIPTS_DIR}/buildprep.inc returned failure"; fi
  fi
  # now do targets
  for TARGET in $TARGETS; do
    echo
    notice "======================================================================="
    starting "target '${TARGET}'"
    command:target "${TARGET}" \
      && command:build ${P44B_BUILD_ARGS} \
      && command:package ${P44B_PACKAGE_ARGS}
    local RET=$?
    if [[ ${RET} -eq 0 ]]; then
      command:save
      if [[ ${DO_DEPLOY} -ne 0 ]]; then
        command:deploy ${P44B_DEPLOY_ARGS}
      fi
      if [[ ${DO_TAG} -ne 0 ]]; then
        command:commitversion ${P44B_COMMITVERSION_ARGS}
        command:tagversion ${P44B_TAGVERSION_ARGS}
      fi
      if [[ ${DO_PUSH} -ne 0 ]]; then
        command:pushversion ${P44B_PUSHVERSION_ARGS}
      fi
    fi
    [[ ${RET} -eq 0 ]]; finished "target '${TARGET}'"
    echo
  done
}



help:run() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} <script name>

Runs a script from the p44build/${SCRIPTS_DIR} directory
The script name can be specified without the ".sh" extension for convenience

ENDHELP
}
command:run() {
  if [[ $# -lt 1 ]]; then
    syntax "specify script to run"
  fi
  local SCRIPT="${P44B_SRC_DIR}/${SCRIPTS_DIR}/$1"
  if [ ! -x "${SCRIPT}" ]; then
    # try with .sh suffix
    SCRIPT="${SCRIPT}.sh"
    if [ ! -x "${SCRIPT}" ]; then
      die "no script '$1' in ${ALIAS} script folder"
    fi
  fi
  shift 1
  # run it
  set_script_env
  info $SCRIPT "$@"
  $SCRIPT "$@"
}


help:send() {
cat >&2 <<ENDHELP
Usage:
- ${SCRIPTNAME} ${FUNCNAME[0]##help:}                        - send the most recently built image for the current target to /tmp on the target
- ${SCRIPTNAME} ${FUNCNAME[0]##help:} <file>                 - send the specified file to /tmp on the target
- ${SCRIPTNAME} ${FUNCNAME[0]##help:} [opts] <file> [<dest>] - send the specified file to <dest> (defaults to /tmp) on the target
Options
  -e, --executable : file is considered an executable from staging_dir/.../usr/bin
  -d, --debuggable : file is considered an executable from staging_dir/.../usr/bin and will be stripped before sending
  -p, --package    : file is a package specification in the form feed/package, the first match of "package"
                     with an actual package .ipk for the current target will be sent.
Notes:
- the TARGET_HOST environment variable must be set to the hostname or IP address of the target

ENDHELP
}
command:send() {
  if [[ -z "${TARGET_HOST}" ]]; then
    die "Need to define TARGET_HOST shell variable"
  fi
  local SRCFILE=""
  local SRCSUFFIX=""
  local DO_STRIP=0
  read_config ".config" # current settings, not saved ones
  while [[ "${1:0:1}" == "-" ]]; do
    case "$1" in
      "-p"|"--package") SRCFILE="${ARCH_BIN}/"; SRCSUFFIX='*'"_${CONFIG_TARGET_ARCH_PACKAGES}.ipk";shift 1;;
      "-e"|"--executable") SRCFILE="${STAGING_ROOT}/usr/bin/" ;shift 1;;
      "-d"|"--debuggable") SRCFILE="${STAGING_ROOT}/usr/bin/" ; DO_STRIP=1; shift 1;;
      *) syntax "unknown option $1";;
    esac
  done
  if [[ $# -eq 0 ]]; then
    # default to current image
    if [[ -z ${SRCFILE} ]]; then
      set_script_env
      local SRCFILE=${BUILT_IMAGE}
    else
      local SRCFILE=$1
    fi
    local TARGPATH='/tmp'
  elif [[ $# -eq 1 ]]; then
    SRCFILE="${SRCFILE}$1"
    local TARGPATH='/tmp'
  elif [[ $# -eq 2 ]]; then
    SRCFILE="${SRCFILE}$1"
    local TARGPATH=$2
  else
    syntax "no more than 2 arguments expected"
  fi
  # expand suffix with wildcards
  if [ -n "$SRCSUFFIX" ]; then
    local S=$(ls -1t ${SRCFILE}${SRCSUFFIX});
    set -- $S
    SRCFILE="$1"
  fi
  if [ ! -f "${SRCFILE}" ]; then
    die "No file found to send"
  fi
  if [[ ${DO_STRIP} -ne 0 ]]; then
    notice "# Stripping symbols from ${SRCFILE}"
    "${TOOLCHAIN_ROOT}/binutils/binutils/strip-new" -o /tmp/debugtarget "${SRCFILE}"
    SRCFILE="/tmp/debugtarget"
  fi
  notice "=== Sending: ${SRCFILE}"
  notice "         to: ${TARGET_HOST}:${TARGPATH}"
  info "scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no ${SRCFILE} root@${TARGET_HOST}:${TARGPATH}"
  scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "${SRCFILE}" "root@${TARGET_HOST}:${TARGPATH}"
  finished "sending"
}


help:debug() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} <executable>

Starts debugging a executable
- sends stripped executable to TARGET_HOST (using ${SCRIPTNAME} send -d <executable>) as /tmp/debugtarget
- starts remote debugging via ./scripts/remote-gdb

Notes:
- the TARGET_HOST environment variable must be set to the hostname or IP address of the target

ENDHELP
}
command:debug() {
  if [[ $# -eq 0 ]]; then
    die "need to specify executable"
  fi
  local EXECNAME=$1
  command:send -d ${EXECNAME}
  local EXECS=$(ls -1t ${BUILDROOT}/build_dir/${TARGETID}/${EXECNAME}-*/${EXECNAME})
  set -- $EXECS
  local EXEC=$1
  notice "=== Debugging: ${EXEC} - paste next line into gdb"
  plain "set remote exec-file /tmp/debugtarget"
  ${BUILDROOT}/scripts/remote-gdb ${TARGET_HOST}:9000 ${EXEC}
  finished "debugging ${EXEC}"
}


help:get() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} <remote file> [<local destination>]

gets a <remote file> from the TARGET_HOST.
By default, the file is stored to /tmp, or to <local destinatio> if specified.

Notes:
- the TARGET_HOST environment variable must be set to the hostname or IP address of the target

ENDHELP
}
command:get() {
  if [[ -z "${TARGET_HOST}" ]]; then
    die "Need to define TARGET_HOST shell variable"
  fi
  if [[ $# -lt 1 || $# -gt 2 ]]; then
    syntax "need to specify source"
  fi
  SRCFILE="$1"
  if [[ $# -eq 1 ]]; then
    local DESTDIR="/tmp"
  else
    local DESTDIR="$2"
  fi
  if [[ ! -d "${DESTDIR}" ]]; then
    die "${DESTDIR} is not a directory"
  fi
  notice "=== Getting: ${TARGET_HOST}:${SRCFILE}"
  notice "         to: ${DESTDIR}"
  info "scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@${TARGET_HOST}:${SRCFILE} ${DESTDIR}"
  scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "root@${TARGET_HOST}:${SRCFILE}" "${DESTDIR}"
  finished "getting file to ${DESTDIR}"
}



help:login() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:} [<host>]

login via ssh to specified <host> or by default to TARGET_HOST.

Notes:
- the TARGET_HOST environment variable must be set to the hostname or IP address of the target

ENDHELP
}
command:login() {
  if [[ $# -eq 0 ]]; then
    if [[ -z "${TARGET_HOST}" ]]; then
      die "Specify host as parameter or define TARGET_HOST shell variable"
    fi
    local HOST="${TARGET_HOST}"
  elif [[ $# -eq 1 ]]; then
    local HOST="$1"
  else
    syntax "need to specify host name or IP address"
  fi
  notice "=== connecting to ${HOST}:"
  info "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@${TARGET_HOST}"
  ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@${TARGET_HOST}
}



help:test() {
cat >&2 <<ENDHELP
Usage: ${SCRIPTNAME} ${FUNCNAME[0]##help:}

dummy test command!

ENDHELP
}
command:test() {
  notice "dummy"
}


# usage
command:usage() {
  notice "Usage:"
  echo "  ${SCRIPTNAME} <command> --help                 - show help for <command>"
  info "Setup and cleanup"
  echo "  ${SCRIPTNAME} new <p44build_dir>               - create a fresh p44build directory as a starting point for a new project"
  echo "  ${SCRIPTNAME} init <p44build_dir>              - initialize buildroot from a an existing p44build directory"
  echo "  ${SCRIPTNAME} switch <p44build_dir>            - (try to) switch to a p44build source directory w/o changing buildroot (possible if patches are equal)"
  echo "  ${SCRIPTNAME} prepare                          - prepare (patch) tree from ${ALIAS} info"
  echo "  ${SCRIPTNAME} instpkg                          - install those packages from feeds that were present at last ${ALIAS} save"
  echo "  ${SCRIPTNAME} restore [opts] <what>...         - restore saved state, --apply to actually modify"
  echo "  ${SCRIPTNAME} cleanup                          - clean up buildroot"
  info "Build commands (in usual sequence)"
  echo "  ${SCRIPTNAME} target [<target>]                - list targets or switch to specified target configuration"
  echo "  ${SCRIPTNAME} build [<args>...]                - call build.sh script if existing, otherwise just call make, with optional args"
  echo "  ${SCRIPTNAME} package [<args>...]              - call package.sh script with with optional args"
  echo "  ${SCRIPTNAME} deploy [<args>...]               - call deploy.sh script with optional args"
  echo "  ${SCRIPTNAME} flash [<args>...]                - call flash.sh script with optional args"
  echo "  ${SCRIPTNAME} save                             - save current build's SHAs of buildroot and tracked packages"
  echo "  ${SCRIPTNAME} commitversion                    - commit the currently saved version to the feed the ${ALIAS} source directory is in"
  echo "  ${SCRIPTNAME} tagversion [-p|--packages]       - tag the currently saved and committed version"
  echo "  ${SCRIPTNAME} pushversion <remote>             - push the currently checked out branch and the version tag to remote"
  info "Automated build of multiple targets"
  echo "  ${SCRIPTNAME} buildtargets [opts] <targets>... - switch to, build, package, save, commit, tag, deploy <targets>"
  info "Testing and debugging"
  echo "  ${SCRIPTNAME} send [opts] <file> [<remote>]    - send file/executable/package/debuggable to target"
  echo "  ${SCRIPTNAME} debug [<executable>]             - start debugging <executable> with gdb"
  echo "  ${SCRIPTNAME} get <file> [<remote>]            - get <remote file> to local <dir> (default: /tmp) from \$TARGET_HOST via scp"
  echo "  ${SCRIPTNAME} login [<host>]                   - connect to specified host or TARGET_HOST via ssh w/o identity checking"
  echo "  ${SCRIPTNAME} run <script> [<args>...]         - run script from ${ALIAS} scripts folder"
  echo ""
}


# main
if [[ $# -lt 1 ]]; then
  command:usage
  exit 1
fi
# global options
for OPT in $@ ; do
  case "$OPT" in
    "-h"|"--help") command:usage; exit 0;;
    *) break 2;;
  esac
done
COMMAND="$1"
shift 1
# per command help
for OPT in $@ ; do
  case "$OPT" in
    "-h"|"--help")
      if has help ${COMMAND}; then
        help:${COMMAND}
      else
        info "no additional help for command '${COMMAND}'"
      fi
      exit 0;;
  esac
done
# run commands
if has command ${COMMAND}; then
  command:${COMMAND} "$@"
else
  err "Unknown subcommand '${COMMAND}'"
  command:usage
  exit 1
fi
