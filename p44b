#!/bin/bash

# p44b: host script for managing LEDE based product builds
shopt -s extglob

# must always be started from buildroot
BUILDROOT="$(pwd -P)"

# the alias name to be used for referring to the script
ALIAS="p44b"

# actual script location and file
SCRIPTDIR="$(dirname $0)"
pushd ${SCRIPTDIR} >/dev/null
SCRIPTDIR="$(pwd -P)"
popd >/dev/null
SCRIPTNAME="$(basename $0)"
SCRIPTFILE="${SCRIPTDIR}/${SCRIPTNAME}"

# derived
P44B_STATE_DIR="${BUILDROOT}/.p44build"

# from state, if existing
if [ -f "${P44B_STATE_DIR}/p44b_src_dir" ]; then
  P44B_SRC_DIR=$(cat "${P44B_STATE_DIR}/p44b_src_dir")
  if [ ! -d "${P44B_SRC_DIR}" ]; then
    echo "Warning: ${ALIAS} source dir does not exist: '${P44B_SRC_DIR}'"
    P44B_SRC_DIR=
  fi
fi
if [ -f "${P44B_STATE_DIR}/target_id" ]; then
  TARGET_ID=$(cat "${P44B_STATE_DIR}/target_id")
fi
# well-known subdirs of P44B_SRC_DIR
PATCHES_DIR="lede-patches"
CONFIGS_DIR="configs"
TRACKING_DIR="tracking"
SCRIPTS_DIR="scripts"


read_config()
{
  pushd ${BUILDROOT} >/dev/null
  # import .config:
  if [[ $# -eq 0 ]]; then
    local DOT_CONFIG_LOCATION="${P44B_SRC_DIR}/${CONFIGS_DIR}/.config-${TARGET_ID}"
  else
    local DOT_CONFIG_LOCATION="${BUILDROOT}/$1"
  fi
  source "${DOT_CONFIG_LOCATION}" 2>/dev/null
  # define derived vars
  VERSION_TAG="${CONFIG_VERSION_NUMBER}"
  if [ ! -z "${CONFIG_P44_FEED_NAME}" ]; then
    VERSION_TAG="${CONFIG_P44_FEED_NAME}/${VERSION_TAG}"
  fi
  VERSION_TAG="${CONFIG_VERSION_PRODUCT}/${VERSION_TAG}/${TARGET_ID}"
  MUSL_SUFFIX=""
  if [[ "${CONFIG_TARGET_SUFFIX#muslgnu}" == "eabi" ]]; then
    MUSL_SUFFIX="_eabi"
  fi
  BUILD_DIR="${BUILDROOT}/build_dir/target-${CONFIG_ARCH}_${CONFIG_CPU_TYPE}_${CONFIG_LIBC}"
  if [ ! -z "${CONFIG_LIBC_VERSION}" ]; then
    BUILD_DIR="${BUILD_DIR}-${CONFIG_LIBC_VERSION}${MUSL_SUFFIX}"
  fi
  IMG_DIST_NAME="${CONFIG_VERSION_DIST}"
  IMG_DIST_NAME_LC=$(echo "$IMG_DIST_NAME" | awk '{print tolower($0)}')
  popd >/dev/null
}




# echo "SCRIPTDIR=$SCRIPTDIR"
# echo "SCRIPTNAME=$SCRIPTNAME"
# echo "SCRIPTFILE=$SCRIPTFILE"
# echo "P44B_STATE_DIR=$P44B_STATE_DIR"
# echo "P44B_SRC_DIR=$P44B_SRC_DIR"
#
# exit 0

# Initialize a buildroot tree for p44b operation
#
# Usage: from a LEDE buildroot:
#    </full/path/to/arbitrary/location>/p44b init <path to p44build source directory of a product>
#
# Does the following
# - put a softlink called "p44b" pointing to the script itself into buildroot
# - creates a .p44build directory in the buildroot
# - remembers the product's p44build source directory in .p44build/p44b_src_dir
# - sets a softlink to the P44B_SRC dir
p44b_init() {
  local NEW_SRC_DIR="$1"
  if [[ $# -ne 1 ]]; then
    p44b_usage
    return 1
  fi
  if [ ! -d "${NEW_SRC_DIR}" ]; then
    echo "Error: '${NEW_SRC_DIR}' is not a directory"
    return 1
  fi
  # create state directory
  if [ -e "${P44B_STATE_DIR}" ]; then
    echo "Error: p44build apparently already initialized - if not, please cleanup first"
    return 1
  fi
  mkdir "${P44B_STATE_DIR}"
  # expand and save the directory
  pushd "${NEW_SRC_DIR}" >/dev/null
  P44B_SRC_DIR="$(pwd -P)"
  popd >/dev/null
  echo -n "${P44B_SRC_DIR}" > "${P44B_STATE_DIR}/p44b_src_dir"
  # create soft link into buildroot to patch dir within sources
  if [ -f "${BUILDROOT}/patches" ]; then
    echo "Error: non-softlink '${BUILDROOT}/patches' already exists"
    return 1
  fi
  ln -sf "${P44B_SRC_DIR}/${PATCHES_DIR}" "${BUILDROOT}/patches"
  # create convenience soft link to script itself in buildroot (but do not replace regular file, should there be one)
  if [ ! -f "${BUILDROOT}/${ALIAS}" ]; then
    ln -sf "${SCRIPTFILE}" "${BUILDROOT}/${ALIAS}"
  fi
  return 0
}


# cleanup
p44b_cleanup() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  # Cleanup buildroot
  # - make sure patches are removed
  pushd "${BUILDROOT}" >/dev/null
  quilt pop -af
  git reset --hard
  popd >/dev/null
  # - remove the quilt working dir
  rm -rf "${BUILDROOT}/.pc"
  # - remove the softlink to the actual patches (but only softlink!)
  if [ -h "${BUILDROOT}/patches" ]; then
    rm "${BUILDROOT}/patches"
  fi
  # - remove the p44build state dir
  if [ -d "${P44B_STATE_DIR}" ]; then
    rm -rf "${P44B_STATE_DIR}"
  fi
  # Note: do not remove the convenience link (will be updated in case another version of the script is used explicitly)
  return 0
}


# Prepare the tree
# - removes current patches
# - discards previous changes to the tree (if some are present, these will be stashed first)
# - checks out the buildroot commit as recorded in $P44B_SRC_DIR/buildroot_checkout
# - applies all buildroot patches
p44b_prepare() {
  # checkout the buildroot checkout
  if [ -f "${P44B_SRC_DIR}/buildroot_checkout" ]; then
    local BUILDROOT_CHECKOUT=$(cat "${P44B_SRC_DIR}/buildroot_checkout")
    pushd ${BUILDROOT} >/dev/null
    # remove patches that might be there
    quilt pop -a
    # stash just in case, to avoid loosing data
    git stash
    # switch to correct buildroot state
    git reset --hard
    git checkout "${BUILDROOT_CHECKOUT}"
    # apply the patches
    quilt push -a
    # clean feeds from MacOS folder state files
    find ${BUILDROOT}/feeds -name .DS_Store -delete
  else
    echo "Warning: no buildroot_checkout (might want to use ${TRACKING_DIR}/buildroot_SHA or ${TRACKING_DIR}/buildroot_VERS)"
  fi
}


# Install those packages that were present at last save
# - if last save has created a install_packages.sh
p44b_instpkg() {
  # checkout the buildroot checkout
  if [ -f "${P44B_SRC_DIR}/${TRACKING_DIR}/install_packages.sh" ]; then
    bash ${P44B_SRC_DIR}/${TRACKING_DIR}/install_packages.sh
  else
    echo "Warning: no install_packages.sh found. You might want to install all packages instead with ./scripts/feeds install -a"
  fi
}



# Configure for a specific target
#
# Does the following
# - cleans tmp/
# - reindexes package feeds
# - copies target's diffconfig to .config and expands it with make defconfig
p44b_target() {
  if [[ $# -eq 0 ]]; then
    # list targets
    TARGETS="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig"*
    for TG in ${TARGETS}; do
      echo "- ${TG##*/diffconfig-}"
    done
    return 0
  fi
  if [[ $# -ne 1 ]]; then
    p44b_usage
    return 1
  fi
  local NEW_TARGET_ID="$1"
  local DIFFCONFIG="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig-${NEW_TARGET_ID}"
  if [ ! -f "${DIFFCONFIG}" ]; then
    echo "Error: buildroot configuration file '${DIFFCONFIG}' not found"
    return 1
  fi
  # remember the target identifier
  TARGET_ID="${NEW_TARGET_ID}"
  echo -n "${TARGET_ID}" > "${P44B_STATE_DIR}/target_id"
  # update the package indices
  rm -rf ${BUILDROOT}/tmp 2>/dev/null
  pushd ${BUILDROOT} >/dev/null
  ./scripts/feeds update -i
  # copy the config and expand
  cp "${DIFFCONFIG}" "${BUILDROOT}/.config"
  make defconfig
  popd >/dev/null
  # show the status
  p44b_status
}


# restores the current build state
# - check only: SHA/version of LEDE
# - feeds.conf
# - SHA of feeds
# - SHA of specified packages
# - config for the current target
p44b_restore() {
  if [[ $# -lt 1 ]]; then
    p44b_usage
    return 1
  fi
  local BYSHA=0
  local APPLY=0
  local DO_ROOT=0
  local DO_FEEDS=0
  local DO_PACKAGES=0
  local DO_TARGET=0
  for OPT in $@ ; do
    case "$OPT" in
      "--sha") BYSHA=1;;
      "--apply") APPLY=1;;
      "root") DO_ROOT=1;;
      "feeds") DO_FEEDS=1;;
      "packages") DO_PACKAGES=1;;
      "target") DO_TARGET=1;;
      *) echo "unknown option $OPT"; return 1;;
    esac
  done
  if [[ -z "${TARGET_ID}" || -z "${P44B_SRC_DIR}" ]]; then
    echo "No target selected, cannot restore"
    return 1
  fi
  # diffconfig for current target
  local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
  # check if buildroot matches
  if [[ ${DO_ROOT} -ne 0 ]]; then
    pushd "${BUILDROOT}" >/dev/null
    local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
    if [[ ${BYSHA} -ne 0 ]]; then
      local CURRENT=$(git rev-parse HEAD)
      local SAVED=$(cat "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA")
    else
      local CURRENT=$(git rev-parse --abbrev-ref HEAD)
      local SAVED=$(cat "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_VERS")
    fi
    if [[ "${CURRENT}" != "${SAVED}" ]]; then
      echo "Buildroot originally saved from was at '${SAVED}', but is now at '${CURRENT}'"
      if [[ ${APPLY} -ne 0 ]]; then
        echo "**** NOT automatically changing this -> manually checkout the correct buildroot commit"
        return 1;
      fi
    fi
    echo "Buildroot state is correct: '${CURRENT}'"
    # current feeds.conf
    if ! cmp -s "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot" feeds.conf; then
      if [[ ${APPLY} -ne 0 ]]; then
        echo "feeds.conf has changed: moving original to feeds.conf_ORIG and putting new one in place"
        mv feeds.conf "feeds.conf_ORIG_$(date +%Y-%m-%d_%H:%M:%S)"
        cp "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot" feeds.conf
      else
        echo "feeds.conf has changed:"
        diff "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot" feeds.conf
        echo ""
      fi
    else
      echo "feeds.conf is unchanged"
    fi
    popd >/dev/null
  fi
  # check feed states
  if [[ ${DO_FEEDS} -ne 0 ]]; then
    if [[ ${BYSHA} -ne 0 ]]; then
      local FEEDSTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_SHA"
    else
      local FEEDSTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_VERS"
    fi
    while IFS='' read -r line || [[ -n "$line" ]]; do
      if [[ "${line:0:1}" != "#" ]]; then
        local FEED="${line/ *}"
        local spec="${line:((${#FEED}+1))}"
        local URL="${spec%:*}"
        local SAVED="${spec:((${#URL}+1))}"
        pushd "${BUILDROOT}/feeds/${FEED}" >/dev/null
        if [[ ${BYSHA} -ne 0 ]]; then
          local CURRENT=$(git rev-parse HEAD)
        else
          local CURRENT=$(git rev-parse --abbrev-ref HEAD)
        fi
        popd >/dev/null
        if [[ "${CURRENT}" != "${SAVED}" ]]; then
          echo "***** feed ${FEED} should be at '${SAVED}' but is at '${CURRENT}'"
          if [[ ${APPLY} -ne 0 ]]; then
            "pushd ${BUILDROOT}/feeds/${FEED}; git stash; git checkout ${SAVED}; popd"
          else
            echo "pushd ${BUILDROOT}/feeds/${FEED}; git stash; git checkout ${SAVED}; popd"
          fi
        fi
      fi
    done < "${FEEDSTATES}"
  fi
  # modify makefiles of tracked packages to point to saved versions
  if [[ ${DO_PACKAGES} -ne 0 ]]; then
    if [[ ${BYSHA} -ne 0 ]]; then
      local PACKAGESTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
    else
      local PACKAGESTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
    fi
    while IFS='' read -r line || [[ -n "$line" ]]; do
      if [[ "${line:0:1}" != "#" ]]; then
        local pspec="${line/ *}"
        local FEED="${pspec/\/*}"
        local PNAME="${pspec:((${#FEED}+1))}"
        local spec="${line:((${#pspec}+1))}"
        local URL="${spec%:*}"
        local SAVED="${spec:((${#URL}+1))}"
        #echo "FEED=${FEED}, PNAME=${PNAME}, URL=${URL}, SAVED=${SAVED}"
        pushd "${BUILDROOT}/feeds/${FEED}/${PNAME}" >/dev/null
        local mfn="Makefile_ORIG_$(date +%Y-%m-%d_%H:%M:%S)"
        sed -E \
         -e "/PKG_SOURCE_URL:=/s|PKG_SOURCE_URL:=(.*)$|PKG_SOURCE_URL:=${URL}|" \
         -e "/PKG_SOURCE_VERSION:=/s|PKG_SOURCE_VERSION:=(.*)$|PKG_SOURCE_VERSION:=${SAVED}|" \
         Makefile > "/tmp/${mfn}"
        if cmp -s Makefile "/tmp/${mfn}"; then
          echo "${FEED}/${PNAME}: Makefile unchanged"
        else
          if [[ ${APPLY} -ne 0 ]]; then
            echo "${FEED}/${PNAME}: Makefile updated: PKG_SOURCE_URL='${URL}', PKG_SOURCE_VERSION='${SAVED}' - original: ${mfn}"
            mv Makefile "${mfn}"
            cp "/tmp/${mfn}" Makefile
          else
            echo "${FEED}/${PNAME}: Makefile needs to update: PKG_SOURCE_URL='${URL}', PKG_SOURCE_VERSION='${SAVED}'"
            diff Makefile "/tmp/${mfn}"
            echo ""
          fi
          rm "/tmp/${mfn}"
        fi
        popd >/dev/null
      fi
    done < "${PACKAGESTATES}"
  fi
  # target config re-apply
  if [[ ${DO_TARGET} -ne 0 ]]; then
    pushd "${BUILDROOT}" >/dev/null
    local cfn=".config_ORIG_$(date +%Y-%m-%d_%H:%M:%S)"
    if [[ ${APPLY} -ne 0 ]]; then
      echo "Re-applying target config, original version in ${cfn}"
      cp .config "${cfn}"
      p44b_target "${TARGET_ID}"
    else
      ./scripts/diffconfig.sh >"/tmp/diffconfig_${TARGET_ID}"
      echo "Target diffconfig has changed, should re-apply target settings:"
      diff "/tmp/diffconfig_${TARGET_ID}" "${CONFIGDIR}/diffconfig-${TARGET_ID}"
    fi
    popd >/dev/null
  fi
}



# saves the current build state
# - SHA of LEDE
# - feeds.conf as a reference
# - diffconfig for current target
# - SHA of feeds
# - SHA of specified packages
# - script for installing stuff from feeds (note: feeds.conf.default is made of LEDE+patches)
p44b_save() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [[ -z "${TARGET_ID}" || -z "${P44B_SRC_DIR}" ]]; then
    echo "No target selected, cannot save"
    return 1
  fi
  pushd ${BUILDROOT} >/dev/null
  # clean feeds from MacOS folder state files
  find ${BUILDROOT}/feeds -name .DS_Store -delete
  # SHA and branch of buildroot
  mkdir "${P44B_SRC_DIR}/${TRACKING_DIR}" 2>/dev/null
  local GITREV=$(git rev-parse HEAD)
  local GITVERS=$(git rev-parse --abbrev-ref HEAD)
  echo "builroot: built from ${GITVERS} (SHA:${GITREV})"
  echo "${GITREV}" >"${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA"
  echo "${GITVERS}" >"${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_VERS"
  # current feeds.conf
  cp feeds.conf "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot"
  # diffconfig for current target
  local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
  ./scripts/diffconfig.sh >"${CONFIGDIR}/diffconfig-${TARGET_ID}"
  # complete config for reference purposes
  cp .config "${CONFIGDIR}/.config-${TARGET_ID}"
  popd >/dev/null
  # Capture installed packages from feeds (as a script that can be run to update feeds and install the packages)
  local INSTPKGS="${P44B_SRC_DIR}/${TRACKING_DIR}/install_packages.sh"
  echo "# Run this script to install all packages that were installed at the time of p44b save" >"${INSTPKGS}"
  FEEDS=$(find ${BUILDROOT}/package/feeds -type d -depth 1 -exec "echo" "{}" ";")
  for FEED in ${FEEDS}; do
    FEEDNAME=$(basename ${FEED})
    #echo "--- feed=${FEEDNAME} dir=${FEED}"
    pushd ${FEED} >/dev/null
    echo "./scripts/feeds update ${FEEDNAME}" >>"${INSTPKGS}"
    for INSTPDIR in *; do
      #echo "---   instpdir=${INSTPDIR}"
      local CMNT=""
      local INSTPNAMES=$(sed -E -n -e "/^Source-Makefile: +feeds\/${FEEDNAME}.*\/${INSTPDIR}\/Makefile/,/^Source-Makefile:/s/^Package: +([-a-zA-Z_]+)/\1/p" ${BUILDROOT}/feeds/${FEEDNAME}.index)
      for INSTPNAME in ${INSTPNAMES}; do
        #echo "---     instpname=${INSTPNAME}"
        echo "${CMNT}./scripts/feeds install -p ${FEEDNAME} ${INSTPNAME}" >>"${INSTPKGS}"
        # installing one of the packages from a makefile is sufficient, show but comment out the other packages made available as well
        CMNT="#"
      done
    done
    popd >/dev/null
  done
  # Capture state of feeds
  echo "# feed giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_VERS"
  echo "# feed giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_SHA"
  pushd "${BUILDROOT}/feeds" >/dev/null
  for FEED in !(*.*) ; do
    pushd "${FEED}" >/dev/null
    local GITURL=$(git remote show origin | sed -ne "/Fetch URL:/s/ *Fetch URL: //p")
    local GITREV=$(git rev-parse HEAD)
    local GITVERS=$(git rev-parse --abbrev-ref HEAD)
    echo "feed ${FEED}: origin at ${GITURL}:${GITVERS} (SHA:${GITREV})"
    echo "${FEED} ${GITURL}:${GITVERS}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_VERS"
    echo "${FEED} ${GITURL}:${GITREV}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_SHA"
    popd >/dev/null
  done
  popd >/dev/null
  # Track package source SHAs/versions
  read_config
  # go through tracked packages
  if [ ! -f "${P44B_SRC_DIR}/tracked_packages" ]; then
    echo "no tracked_packages file -> nothing to track"
    return 0
  fi
  local PACKAGES=$(cat "${P44B_SRC_DIR}/tracked_packages");
  # remove the previous trackings
  echo "# feed/package giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
  echo "# feed/package giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
  local PUSHTAGS="${P44B_SRC_DIR}/${TRACKING_DIR}/pushtags.sh"
  echo "#!/bin/bash" >"${PUSHTAGS}"
  echo "pushd /tmp; rm -rf /tmp/p44b_temp; mkdir p44b_temp; cd p44b_temp" >>"${PUSHTAGS}"
  for PSPEC in ${PACKAGES}; do
    local FEEDNAME=${PSPEC%%/*}
    local PKGNAME=${PSPEC#*/}
    #echo "feed=$FEEDNAME pgk=$PKGNAME"
    local PKGDIR="${BUILDROOT}/feeds/${FEEDNAME}/${PKGNAME}"
    if [ ! -d "${PKGDIR}" ]; then
      echo "*** package not found for ${PSPEC}"
    else
      #echo "packagedir=$PKGDIR"
      # collect info from feed
      local PKG_NAME=$(sed -n -e "/^PKG_NAME:=/s/PKG_NAME:=//p" "${PKGDIR}/Makefile")
      local PKG_VERSION=$(sed -n -e "/^PKG_VERSION:=/s/PKG_VERSION:=//p" "${PKGDIR}/Makefile")
      local PKG_SOURCE_URL=$(sed -n -e "/^PKG_SOURCE_URL:=/s/PKG_SOURCE_URL:=//p" "${PKGDIR}/Makefile")
      local PKG_SOURCE_VERSION=$(sed -n -e "/^PKG_SOURCE_VERSION:=/s/PKG_SOURCE_VERSION:=//p" "${PKGDIR}/Makefile")
      local PKGNAMEVERS="${PKG_NAME}-${PKG_VERSION}"
      # build-dir as defined in makefile
      local PD=$(sed -n -e "/^PKG_BUILD_DIR:=/s/PKG_BUILD_DIR:=//p" "${PKGDIR}/Makefile")
      local PD=${PD//\$\(/\$\{}
      local PD=${PD//\)/\}}
      eval PKGBUILDDIR="$PD"
      #echo "PKG_NAME=$PKG_NAME, PKG_VERSION=$PKG_VERSION, PKG_SOURCE_VERSION=$PKG_SOURCE_VERSION, PD=$PD"
      #echo "package build dir: ${PKGBUILDDIR}"
      # collect info from build
      if [ ! -d "${PKGBUILDDIR}" ]; then
        echo "*** ${PKGNAMEVERS}: no build directory found"
      elif [ ! -e "${PKGBUILDDIR}/.gitdownload_url" ]; then
        echo "*** ${PKGNAMEVERS}: was not built with p44b checkout revision tracking"
      else
        # get info recorded during build
        local BUILDURL=$(cat "${PKGBUILDDIR}/.gitdownload_url")
        local BUILDREV=$(cat "${PKGBUILDDIR}/.gitdownload_rev")
        local BUILDVERS=$(cat "${PKGBUILDDIR}/.gitdownload_version")
        # get info from source repo
        if [[ "${BUILDREV}" != "${BUILDVERS}" && "${PKG_SOURCE_VERSION}" != "${BUILDREV}" ]]; then
          # vers is a ref (branch, tag) that can move -> get the SHA of that ref from the git source repo
          local R=$(git ls-remote "${PKG_SOURCE_URL}" "${PKG_SOURCE_VERSION}")
          local GITREV="${R%%[[:blank:]]*}"
          local GITVERS="${PKG_SOURCE_VERSION}"
        else
          # vers is a SHA that cannot move, so no need to check with source repo
          local GITREV="${BUILDREV}"
          local GITVERS=
        fi
        # consistency checks
        if [[ "${BUILDVERS}" != "${PKG_SOURCE_VERSION}" && "${BUILDREV}" != "${PKG_SOURCE_VERSION}" ]]; then
          echo "*** ${PKGNAMEVERS}: branch/commit recorded in build (${BUILDVERS}) differs from PKG_SOURCE_VERSION (${PKG_SOURCE_VERSION})"
        elif [[ "${PKG_SOURCE_URL}" != "${BUILDURL}" ]]; then
          echo "*** ${PKGNAMEVERS}: URL recorded in build (${BUILDURL}) differs from PKG_SOURCE_URL (${PKG_SOURCE_URL})"
        else
          # checks ok, now record
          echo "package ${PKGNAMEVERS}: was built from ${BUILDURL}:${BUILDVERS} (SHA:${BUILDREV})"
          # - record fixed sha source
          echo "${PSPEC} ${BUILDURL}:${BUILDREV}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
          # - record version/branch source
          echo "${PSPEC} ${BUILDURL}:${BUILDVERS}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
          if [[ "${GITREV}" != "${BUILDREV}" ]]; then
            echo "*** ${PKGNAMEVERS}: Warning: SHA recorded in build (${BUILDREV}) differs from 'git ls-remote ... ${PKG_SOURCE_VERSION}' (${GITREV})"
            echo "# ${PSPEC}: build SHA differs from 'git ls-remote ... ${PKG_SOURCE_VERSION}' (${GITREV})" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
            echo "# ${PSPEC}: WARNING: There is no branch/tag at ${BUILDREV} we could clone from: cannot tag" >>"${PUSHTAGS}"
          else
            # - create entry for tagging source repositories in tagging script
            if [[ -n "${GITVERS}" ]]; then
              echo "git clone --depth 1 --no-checkout --single-branch --branch ${BUILDVERS} ${PKG_SOURCE_URL} ${PKG_NAME}" >>"${PUSHTAGS}"
            else
              # we do not know which branch we need, just clone normally in full depth
              echo "git clone --no-checkout ${PKG_SOURCE_URL} ${PKG_NAME}" >>"${PUSHTAGS}"
            fi
            echo "pushd ${PKG_NAME}" >>"${PUSHTAGS}"
            echo "git tag -f ${VERSION_TAG} ${BUILDREV}" >>"${PUSHTAGS}"
            echo "git push -f origin ${VERSION_TAG}" >>"${PUSHTAGS}"
            echo "popd" >>"${PUSHTAGS}"
            chmod a+x "${PUSHTAGS}"
          fi
        fi
      fi
    fi
  done
  echo "popd" >>"${PUSHTAGS}"
}


# commit version as currently saved
p44b_commitversion() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    echo "Nothing saved, cannot commit"
    return 1
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    echo ".config does not contain version information"
    return 1
  fi
  # clean feeds from MacOS folder state files
  find ${BUILDROOT}/feeds -name .DS_Store -delete
  pushd "${P44B_SRC_DIR}" >/dev/null
  git add -A "${P44B_SRC_DIR}"
  git commit -m "${VERSION_TAG}"
  popd >/dev/null
  echo "# You might want to amend this commit with changes outside the ${ALIAS} directory"
}



# tag the current commit with a version tag
p44b_tagversion() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    echo "Nothing saved, cannot tag"
    return 1
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    echo ".config does not contain version information"
    return 1
  else
    echo "Tagging: ${VERSION_TAG}"
    pushd "${P44B_SRC_DIR}" >/dev/null
    git tag -f "${VERSION_TAG}"
    popd >/dev/null
    echo "# You might also want to tag tracked packages by executing:"
    echo "${P44B_SRC_DIR}/tracking/pushtags.sh"
  fi
}


# push the current feed's master and the version tag to origin
p44b_pushversion() {
  if [[ $# -ne 1 ]]; then
    p44b_usage
    return 1
  fi
  local REMOTE="$1"
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    echo "Nothing saved, cannot push"
    return 1
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    echo ".config does not contain version information"
    return 1
  else
    # detect branch
    pushd "${P44B_SRC_DIR}" >/dev/null
    local BRANCH=$(git rev-parse --abbrev-ref HEAD)
    echo "Pushing branch '${BRANCH}' and tag '${VERSION_TAG}' -> remote '${REMOTE}'"
    git push ${REMOTE} ${BRANCH}
    git push ${REMOTE} -f "${VERSION_TAG}"
    popd >/dev/null
  fi
}




# display status
p44b_status() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [ ! -z "${P44B_SRC_DIR}" ]; then
    echo "Initialized with ${ALIAS} sources at '${P44B_SRC_DIR}'"
    echo "Current target  : '${TARGET_ID}'"
    read_config ".config" # current settings, not saved ones
    echo "Distribution    : ${CONFIG_VERSION_DIST}"
    echo "Product         : ${CONFIG_VERSION_PRODUCT}"
    echo "HW Revision     : ${CONFIG_VERSION_HWREV}"
    echo "Current version : ${CONFIG_VERSION_NUMBER}"
    echo "Current feed    : ${CONFIG_P44_FEED_NAME}"
    echo "Build dir       : ${BUILD_DIR}"
    echo "target host     : ${TARGET_HOST}"
  else
    echo "This tree is not initialized for ${ALIAS} yet"
  fi
}


p44b_run() {
  if [[ $# -lt 1 ]]; then
    p44b_usage
    return 1
  fi
  local SCRIPT="${P44B_SRC_DIR}/${SCRIPTS_DIR}/$1"
  if [ ! -f "${SCRIPT}" ]; then
    echo "no script '$1' in ${ALIAS} script folder"
    return 1
  fi
  shift 1
  # run it
  $SCRIPT "$@"
}


p44b_send() {
  if [[ -z "${TARGET_HOST}" ]]; then
    echo "Need to define TARGET_HOST shell variable"
    return 1
  fi
  if [[ $# -eq 0 ]]; then
    # default to current image
    read_config ".config" # current settings, not saved ones
    local SRCIMGS=$(ls -1t ${BUILDROOT}/bin/targets/${CONFIG_TARGET_BOARD}/${CONFIG_TARGET_SUBTARGET}/${IMG_DIST_NAME_LC}-${CONFIG_VERSION_NUMBER}*-${CONFIG_TARGET_BOARD}-${CONFIG_TARGET_SUBTARGET}-${CONFIG_TARGET_PROFILE##DEVICE_}-*);
    set -- $SRCIMGS
    local SRCFILE=$1
  elif [[ $# -eq 1 ]]; then
    local SRCFILE=$1
    local TARGPATH='/tmp'
  elif [[ $# -eq 2 ]]; then
    local SRCFILE=$1
    local TARGPATH=$2
  else
    p44b_usage
    return 1
  fi
  echo "# Sending: ${SRCFILE} to ${TARGET_HOST}:${TARGPATH}"
  echo "scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no ${SRCFILE} root@${TARGET_HOST}:${TARGPATH}"
  scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "${SRCFILE}" "root@${TARGET_HOST}:${TARGPATH}"
  echo "...done"
}


p44b_get() {
  if [[ -z "${TARGET_HOST}" ]]; then
    echo "Need to define TARGET_HOST shell variable"
    return 1
  fi
  if [[ $# -lt 1 || $# -gt 2 ]]; then
    p44b_usage
    return 1
  fi
  SRCFILE="$1"
  if [[ $# -eq 1 ]]; then
    local DESTDIR="/tmp"
  else
    local DESTDIR="$2"
  fi
  if [[ ! -d "${DESTDIR}" ]]; then
    echo "${DESTDIR} is not a directory"
    return 1
  fi
  echo "# Getting: ${TARGET_HOST}:${SRCFILE} to ${DESTDIR}"
  echo "scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@${TARGET_HOST}:${SRCFILE} ${DESTDIR}"
  scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "root@${TARGET_HOST}:${SRCFILE}" "${DESTDIR}"
  echo "...done"
}



p44b_login() {
  if [[ $# -eq 0 ]]; then
    if [[ -z "${TARGET_HOST}" ]]; then
      echo "Specify host as parameter or define TARGET_HOST shell variable"
      return 1
    fi
    local HOST="${TARGET_HOST}"
  elif [[ $# -eq 1 ]]; then
    local HOST="$1"
  else
    p44b_usage
    return 1
  fi
  echo "# connecting to ${HOST}:"
  echo "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@${TARGET_HOST}"
  ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@${TARGET_HOST}
}



p44b_test() {
  echo "dummy"
}


# usage
p44b_usage() {
  echo "usage: ${SCRIPTNAME} status                         - show status"
  echo "   or: ${SCRIPTNAME} init <srcdir>                  - initialize buildroot from a ${ALIAS} source directory"
  echo "   or: ${SCRIPTNAME} cleanup                        - clean up buildroot"
  echo "   or: ${SCRIPTNAME} prepare                        - prepare (patch) tree from ${ALIAS} info"
  echo "   or: ${SCRIPTNAME} instpkg                        - install those packages from feeds that were present at last ${ALIAS} save"
  echo "   or: ${SCRIPTNAME} target [<target>]              - list targets or switch to specified target configuration"
  echo "   or: ${SCRIPTNAME} save                           - save current build's SHAs of buildroot and tracked packages"
  echo "   or: ${SCRIPTNAME} restore [--sha][--apply] (root|feeds|packages) - restore saved state, --apply to actually modify, --sha to use sha, not branch names"
  echo "   or: ${SCRIPTNAME} send [<file> [<remote path>]]  - send <file> (default: built image for current target) to \$TARGET_HOST via scp (default path: /tmp)"
  echo "   or: ${SCRIPTNAME} get <remote file> [<dir>]      - get <remote file> to local <dir> (default: /tmp) from \$TARGET_HOST via scp"
  echo "   or: ${SCRIPTNAME} login [<host>]                 - connect to specified host or TARGET_HOST via ssh w/o identity checking"
  echo "   or: ${SCRIPTNAME} commitversion                  - commit the currently saved version to the feed the ${ALIAS} source directory is in"
  echo "   or: ${SCRIPTNAME} tagversion                     - tag the currently saved and committed version"
  echo "   or: ${SCRIPTNAME} pushversion <remote>           - push the currently checked out branch and the version tag to remote"
  echo "   or: ${SCRIPTNAME} run <script> [<args>...]       - run script from ${ALIAS} scripts folder"
}


# main
if [[ $# -lt 1 ]]; then
  p44b_usage
  exit 1
fi
COMMAND="$1"
shift 1
case ${COMMAND} in
  "status")
    p44b_status "$@"
    ;;
  "init")
    p44b_init "$@"
    ;;
  "cleanup")
    p44b_cleanup "$@"
    ;;
  "prepare")
    p44b_prepare "$@"
    ;;
  "instpkg")
    p44b_instpkg "$@"
    ;;
  "target")
    p44b_target "$@"
    ;;
  "send")
    p44b_send "$@"
    ;;
  "get")
    p44b_get "$@"
    ;;
  "login")
    p44b_login "$@"
    ;;
  "save")
    p44b_save "$@"
    ;;
  "restore")
    p44b_restore "$@"
    ;;
  "commitversion")
    p44b_commitversion "$@"
    ;;
  "tagversion")
    p44b_tagversion "$@"
    ;;
  "pushversion")
    p44b_pushversion "$@"
    ;;
  "run")
    p44b_run "$@"
    ;;
  "test")
    p44b_test "$@"
    ;;
  *)
    echo "Unknown subcommand '${COMMAND}'"
    p44b_usage
    exit 1
    ;;
esac
