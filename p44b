#!/bin/bash

# p44b: host script for managing LEDE based product builds

# must always be started from buildroot
BUILDROOT="$(pwd -P)"

# the alias name to be used for referring to the script
ALIAS="p44b"

# actual script location and file
SCRIPTDIR="$(dirname $0)"
pushd ${SCRIPTDIR} >/dev/null
SCRIPTDIR="$(pwd -P)"
popd >/dev/null
SCRIPTNAME="$(basename $0)"
SCRIPTFILE="${SCRIPTDIR}/${SCRIPTNAME}"

# derived
P44B_STATE_DIR="${BUILDROOT}/.p44build"

# from state, if existing
if [ -f "${P44B_STATE_DIR}/p44b_src_dir" ]; then
  P44B_SRC_DIR=$(cat "${P44B_STATE_DIR}/p44b_src_dir")
  if [ ! -d "${P44B_SRC_DIR}" ]; then
    echo "Warning: ${ALIAS} source dir does not exist: '${P44B_SRC_DIR}'"
    P44B_SRC_DIR=
  fi
fi
if [ -f "${P44B_STATE_DIR}/target_id" ]; then
  TARGET_ID=$(cat "${P44B_STATE_DIR}/target_id")
fi
# well-known subdirs of P44B_SRC_DIR
PATCHES_DIR="lede-patches"
CONFIGS_DIR="configs"
TRACKING_DIR="tracking"


read_config()
{
  pushd ${BUILDROOT} >/dev/null
  # import .config:
  source "${P44B_SRC_DIR}/${CONFIGS_DIR}/.config-${TARGET_ID}" 2>/dev/null
  # define derived vars
  VERSION_TAG="${TARGET_ID}_${CONFIG_VERSION_NUMBER}"
  if [ ! -z "${CONFIG_P44_FEED_NAME}" ]; then
    VERSION_TAG="${VERSION_TAG}_${CONFIG_P44_FEED_NAME}"
  fi
  popd >/dev/null
}




# echo "SCRIPTDIR=$SCRIPTDIR"
# echo "SCRIPTNAME=$SCRIPTNAME"
# echo "SCRIPTFILE=$SCRIPTFILE"
# echo "P44B_STATE_DIR=$P44B_STATE_DIR"
# echo "P44B_SRC_DIR=$P44B_SRC_DIR"
#
# exit 0

# Initialize a buildroot tree for p44b operation
#
# Usage: from a LEDE buildroot:
#    </full/path/to/arbitrary/location>/p44b init <path to p44build source directory of a product>
#
# Does the following
# - put a softlink called "p44b" pointing to the script itself into buildroot
# - creates a .p44build directory in the buildroot
# - remembers the product's p44build source directory in .p44build/p44b_src_dir
# - sets a softlink to the P44B_SRC dir
p44b_init() {
  local NEW_SRC_DIR="$1"
  if [[ $# -ne 1 ]]; then
    p44b_usage
    return 1
  fi
  if [ ! -d "${NEW_SRC_DIR}" ]; then
    echo "Error: '${NEW_SRC_DIR}' is not a directory"
    return 1
  fi
  # create state directory
  if [ -e "${P44B_STATE_DIR}" ]; then
    echo "Error: p44build apparently already initialized - if not, please cleanup first"
    return 1
  fi
  mkdir "${P44B_STATE_DIR}"
  # expand and save the directory
  pushd "${NEW_SRC_DIR}" >/dev/null
  P44B_SRC_DIR="$(pwd -P)"
  popd >/dev/null
  echo -n "${P44B_SRC_DIR}" > "${P44B_STATE_DIR}/p44b_src_dir"
  # create soft link into buildroot to patch dir within sources
  if [ -f "${BUILDROOT}/patches" ]; then
    echo "Error: non-softlink '${BUILDROOT}/patches' already exists"
    return 1
  fi
  ln -sf "${P44B_SRC_DIR}/${PATCHES_DIR}" "${BUILDROOT}/patches"
  # create convenience soft link to script itself in buildroot (but do not replace regular file, should there be one)
  if [ ! -f "${BUILDROOT}/${ALIAS}" ]; then
    ln -sf "${SCRIPTFILE}" "${BUILDROOT}/${ALIAS}"
  fi
  return 0
}


# cleanup
p44b_cleanup() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  # Cleanup buildroot
  # - make sure patches are removed
  pushd "${BUILDROOT}" >/dev/null
  quilt pop -a
  popd >/dev/null
  # - remove the quilt working dir
  rm -rf "${BUILDROOT}/.pc"
  # - remove the softlink to the actual patches (but only softlink!)
  if [ -h "${BUILDROOT}/patches" ]; then
    rm "${BUILDROOT}/patches"
  fi
  # - remove the p44build state dir
  if [ -d "${P44B_STATE_DIR}" ]; then
    rm -rf "${P44B_STATE_DIR}"
  fi
  # Note: do not remove the convenience link (will be updated in case another version of the script is used explicitly)
  return 0
}


# Prepare the tree for a specific target
#
# Does the following
# - removes current patches
# - discards previous changes to the tree
# - checks out the buildroot commit as recorded in $P44B_SRC_DIR/buildroot_checkout
# - applies all buildroot patches
# - copies target's diffconfig to .config and expands it with make defconfig
p44b_target() {
  if [[ $# -ne 1 ]]; then
    p44b_usage
    return 1
  fi
  local NEW_TARGET_ID="$1"
  local DIFFCONFIG="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig-${NEW_TARGET_ID}"
  if [ ! -f "${DIFFCONFIG}" ]; then
    echo "Error: buildroot configuration file '${DIFFCONFIG}' not found"
    return 1
  fi
  # remember the target identifier
  TARGET_ID="${NEW_TARGET_ID}"
  echo -n "${TARGET_ID}" > "${P44B_STATE_DIR}/target_id"
  # checkout the buildroot checkout
  if [ -f "${P44B_SRC_DIR}/buildroot_checkout" ]; then
    local BUILDROOT_CHECKOUT=$(cat "${P44B_SRC_DIR}/buildroot_checkout")
    pushd ${BUILDROOT} >/dev/null
    # remove patches that might be there
    quilt pop -a
    # stash just in case, to avoid loosing data
    git stash
    # switch to correct buildroot state
    git reset --hard
    git checkout "${BUILDROOT_CHECKOUT}"
    # apply the patches
    quilt push -a
    # copy the config and expand
    cp "${DIFFCONFIG}" "${BUILDROOT}/.config"
    make defconfig
    popd >/dev/null
  else
    echo "Warning: no buildroot_checkout (might want to use ${TRACKING_DIR}/buildroot_SHA or ${TRACKING_DIR}/buildroot_VERS)"
  fi
}


# saves the current build state
# - SHA of LEDE
# - diffconfig for current target
# - TODO: SHA of feeds
# - TODO: SHA of specified packages
p44b_save() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [[ -z "${TARGET_ID}" || -z "${P44B_SRC_DIR}" ]]; then
    echo "No target selected, cannot save"
    return 1
  fi
  pushd ${BUILDROOT} >/dev/null
  # SHA and branch of buildroot
  mkdir "${P44B_SRC_DIR}/${TRACKING_DIR}" 2>/dev/null
  git rev-parse HEAD >"${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA"
  git rev-parse --abbrev-ref HEAD >"${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_VERS"
  # diffconfig for current target
  local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
  ./scripts/diffconfig.sh >"${CONFIGDIR}/diffconfig-${TARGET_ID}"
  # complete config for reference purposes
  cp .config "${CONFIGDIR}/.config-${TARGET_ID}"
  popd >/dev/null
  # Track package source SHAs/versions
  read_config
  local BUILD_DIR="${BUILDROOT}/build_dir/target-${CONFIG_TARGET_ARCH_PACKAGES}_${CONFIG_LIBC}-${CONFIG_LIBC_VERSION}"
  # go through tracked packages
  if [ ! -f "${P44B_SRC_DIR}/tracked_packages" ]; then
    echo "no tracked_packages file -> nothing to track"
    return 0
  fi
  local PACKAGES=$(cat "${P44B_SRC_DIR}/tracked_packages");
  # remove the previous trackings
  echo "# feed/package giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
  echo "# feed/package giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
  local PUSHTAGS="${P44B_SRC_DIR}/${TRACKING_DIR}/pushtags.sh"
  echo "#!/bin/bash" >"${PUSHTAGS}"
  echo "pushd /tmp; rm -rf /tmp/p44b_temp; mkdir p44b_temp; cd p44b_temp" >>"${PUSHTAGS}"
  for PSPEC in ${PACKAGES}; do
    local FEEDNAME=${PSPEC%%/*}
    local PKGNAME=${PSPEC#*/}
    #echo "feed=$FEEDNAME pgk=$PKGNAME"
    local PKGDIR="${BUILDROOT}/feeds/${FEEDNAME}/${PKGNAME}"
    if [ ! -d "${PKGDIR}" ]; then
      echo "*** package not found for ${PSPEC}"
    else
      #echo "packagedir=$PKGDIR"
      # collect info from feed
      local PKG_NAME=$(sed -n -e "/^PKG_NAME:=/s/PKG_NAME:=//p" "${PKGDIR}/Makefile")
      local PKG_VERSION=$(sed -n -e "/^PKG_VERSION:=/s/PKG_VERSION:=//p" "${PKGDIR}/Makefile")
      local PKG_SOURCE_URL=$(sed -n -e "/^PKG_SOURCE_URL:=/s/PKG_SOURCE_URL:=//p" "${PKGDIR}/Makefile")
      local PKG_SOURCE_VERSION=$(sed -n -e "/^PKG_SOURCE_VERSION:=/s/PKG_SOURCE_VERSION:=//p" "${PKGDIR}/Makefile")
      local PKGNAMEVERS="${PKG_NAME}-${PKG_VERSION}"
      # build-dir as defined in makefile
      local PD=$(sed -n -e "/^PKG_BUILD_DIR:=/s/PKG_BUILD_DIR:=//p" "${PKGDIR}/Makefile")
      local PD=${PD//\$\(/\$\{}
      local PD=${PD//\)/\}}
      eval PKGBUILDDIR="$PD"
      #echo "PKG_NAME=$PKG_NAME, PKG_VERSION=$PKG_VERSION, PKG_SOURCE_VERSION=$PKG_SOURCE_VERSION"
      #echo "package build dir: ${PKGBUILDDIR}"
      # collect info from build
      if [ ! -d "${PKGBUILDDIR}" ]; then
        echo "*** ${PKGNAMEVERS}: no build directory found"
      elif [ ! -e "${PKGBUILDDIR}/.gitdownload_url" ]; then
        echo "*** ${PKGNAMEVERS}: was not built with p44b checkout revision tracking"
      else
        local GITURL=$(cat "${PKGBUILDDIR}/.gitdownload_url")
        local GITREV=$(cat "${PKGBUILDDIR}/.gitdownload_rev")
        local GITVERS=$(cat "${PKGBUILDDIR}/.gitdownload_version")
        local R=$(git ls-remote "${PKG_SOURCE_URL}" "${PKG_SOURCE_VERSION}")
        local REV="${R%%[[:blank:]]*}"
        # consistency check
        if [[ "${GITVERS}" != "${PKG_SOURCE_VERSION}" ]]; then
          echo "*** ${PKGNAMEVERS}: branch/commit recorded in build (${GITVERS}) differs from PKG_SOURCE_VERSION (${PKG_SOURCE_VERSION})"
        elif [[ "${PKG_SOURCE_URL}" != "${GITURL}" ]]; then
          echo "*** ${PKGNAMEVERS}: URL recorded in build (${GITURL}) differs from PKG_SOURCE_URL (${PKG_SOURCE_URL})"
        elif [[ "${REV}" != "${GITREV}" ]]; then
          echo "*** ${PKGNAMEVERS}: SHA recorded in build (${GITREV}) differs from git ls-remote (${REV})"
        else
          # checks ok, now record
          echo "${PKGNAMEVERS}: was built from ${GITURL}:${GITVERS} (SHA:${GITREV})"
          # - record fixed sha source
          echo "${PSPEC} ${GITURL}:${GITREV}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
          # - record version/branch source
          echo "${PSPEC} ${GITURL}:${GITVERS}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
          # - create entry for tagging source repositories in tagging script
          echo "git clone --depth 1 --no-checkout --single-branch --branch ${GITVERS} ${PKG_SOURCE_URL} ${PKG_NAME}" >>"${PUSHTAGS}"
          echo "pushd ${PKG_NAME}" >>"${PUSHTAGS}"
          echo "git tag ${VERSION_TAG} ${GITREV}" >>"${PUSHTAGS}"
          echo "git push origin ${VERSION_TAG}" >>"${PUSHTAGS}"
          echo "popd" >>"${PUSHTAGS}"
          chmod a+x "${PUSHTAGS}"
        fi
      fi
    fi
  done
  echo "popd" >>"${PUSHTAGS}"
}


# commit version as currently saved
p44b_commitversion() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    echo "Nothing saved, cannot commit"
    return 1
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    echo ".config does not contain version information"
    return 1
  else
    pushd "${P44B_SRC_DIR}" >/dev/null
    git add -A "${P44B_SRC_DIR}"
    git commit -m "${VERSION_TAG}"
    popd >/dev/null
  fi
}



# tag the current commit with a version tag
p44b_tagversion() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    echo "Nothing saved, cannot tag"
    return 1
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    echo ".config does not contain version information"
    return 1
  else
    echo "Tagging: ${VERSION_TAG}"
    pushd "${P44B_SRC_DIR}" >/dev/null
    git tag "${VERSION_TAG}"
    popd >/dev/null
    echo "# You might also want to tag tracked packages by executing:"
    echo "${P44B_SRC_DIR}/tracking/pushtags.sh"
  fi
}




# display status
p44b_status() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [ ! -z "${P44B_SRC_DIR}" ]; then
    echo "Initialized with ${ALIAS} sources at '${P44B_SRC_DIR}'"
    echo "Current target: '${TARGET_ID}'"
  else
    echo "This tree is not initialized for ${ALIAS} yet"
  fi
}


# usage
p44b_usage() {
  echo "usage: ${SCRIPTNAME} status              - show status"
  echo "   or: ${SCRIPTNAME} init <srcdir>       - initialize buildroot from a ${ALIAS} source directory"
  echo "   or: ${SCRIPTNAME} cleanup             - clean up"
  echo "   or: ${SCRIPTNAME} target <target>     - switch to specified target configuration"
  echo "   or: ${SCRIPTNAME} save                - save current build's SHAs of buildroot and tracked packages"
  echo "   or: ${SCRIPTNAME} commitversion       - commit the currently saved version to the feed the ${ALIAS} source directory is in"
  echo "   or: ${SCRIPTNAME} tagversion          - tag the currently saved and committed version"
}


# main
if [[ $# -lt 1 ]]; then
  p44b_usage
  exit 1
fi
COMMAND="$1"
shift 1
case ${COMMAND} in
  "status")
    p44b_status "$@"
    ;;
  "init")
    p44b_init "$@"
    ;;
  "cleanup")
    p44b_cleanup "$@"
    ;;
  "target")
    p44b_target "$@"
    ;;
  "save")
    p44b_save "$@"
    ;;
  "commitversion")
    p44b_commitversion "$@"
    ;;
  "tagversion")
    p44b_tagversion "$@"
    ;;
  *)
    echo "Unknown subcommand '${COMMAND}'"
    p44b_usage
    exit 1
    ;;
esac



