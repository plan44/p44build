#!/bin/bash

# p44b: host script for managing OpenWrt based product builds
shopt -s extglob

# must always be started from buildroot
BUILDROOT="$(pwd -P)"

# the alias name to be used for referring to the script
ALIAS="p44b"

# actual script location and file
SCRIPTDIR="$(dirname $0)"
pushd ${SCRIPTDIR} >/dev/null
SCRIPTDIR="$(pwd -P)"
popd >/dev/null
SCRIPTNAME="$(basename $0)"
SCRIPTFILE="${SCRIPTDIR}/${SCRIPTNAME}"

# derived
P44B_STATE_DIR="${BUILDROOT}/.p44build"

# from state, if existing
if [ -f "${P44B_STATE_DIR}/p44b_src_dir" ]; then
  P44B_SRC_DIR=$(cat "${P44B_STATE_DIR}/p44b_src_dir")
  if [ ! -d "${P44B_SRC_DIR}" ]; then
    echo "Warning: ${ALIAS} source dir does not exist: '${P44B_SRC_DIR}'"
    P44B_SRC_DIR=
  fi
fi
if [ -f "${P44B_STATE_DIR}/target_id" ]; then
  TARGET_ID=$(cat "${P44B_STATE_DIR}/target_id")
fi
# well-known subdirs of P44B_SRC_DIR
CONFIGS_DIR="configs"
TRACKING_DIR="tracking"
SCRIPTS_DIR="scripts"
GLOBAL_PATCHES_DIR="global-patches"

read_config()
{
  pushd ${BUILDROOT} >/dev/null
  # import .config:
  if [[ $# -eq 0 ]]; then
    local DOT_CONFIG_LOCATION="${P44B_SRC_DIR}/${CONFIGS_DIR}/.config-${TARGET_ID}"
  else
    local DOT_CONFIG_LOCATION="${BUILDROOT}/$1"
  fi
  source "${DOT_CONFIG_LOCATION}" 2>/dev/null
  # define derived vars
  VERSION_TAG="${CONFIG_VERSION_NUMBER}"
  if [ ! -z "${CONFIG_P44_FEED_NAME}" ]; then
    VERSION_TAG="${CONFIG_P44_FEED_NAME}/${VERSION_TAG}"
  fi
  VERSION_TAG="${CONFIG_VERSION_PRODUCT}/${VERSION_TAG}/${TARGET_ID}"
  # musl suffix
  MUSL_SUFFIX=""
  if [[ "${CONFIG_TARGET_SUFFIX#muslgnu}" == "eabi" ]]; then
    MUSL_SUFFIX="_eabi"
  fi
  LIBCID="${CONFIG_LIBC}"
  if [ ! -z "${CONFIG_LIBC_VERSION}" ]; then
    LIBCID="${LIBCID}-${CONFIG_LIBC_VERSION}${MUSL_SUFFIX}"
  else
    LIBCID="${LIBCID}${MUSL_SUFFIX}"
  fi
  # target/toolchain identifying string
  TARGETID="target-${CONFIG_ARCH}_${CONFIG_CPU_TYPE}_${LIBCID}"
  TOOLCHAINID="toolchain-${CONFIG_ARCH}_${CONFIG_CPU_TYPE}_gcc-${CONFIG_GCC_VERSION}_${LIBCID}"
  # build dir
  BUILD_DIR="${BUILDROOT}/build_dir/${TARGETID}"
  # toolchain root
  TOOLCHAIN_ROOT="${BUILDROOT}/build_dir/${TOOLCHAINID}"
  # staging root
  STAGING_ROOT="${BUILDROOT}/staging_dir/${TARGETID}/root-${CONFIG_TARGET_BOARD}"
  # dist name
  IMG_DIST_NAME="${CONFIG_VERSION_DIST}"
  IMG_DIST_NAME_LC=$(echo "$IMG_DIST_NAME" | awk '{print tolower($0)}')
  popd >/dev/null
}




# echo "SCRIPTDIR=$SCRIPTDIR"
# echo "SCRIPTNAME=$SCRIPTNAME"
# echo "SCRIPTFILE=$SCRIPTFILE"
# echo "P44B_STATE_DIR=$P44B_STATE_DIR"
# echo "P44B_SRC_DIR=$P44B_SRC_DIR"
#
# exit 0

# Initialize a buildroot tree for p44b operation
#
# Usage: from a OpenWrt buildroot:
#    </full/path/to/arbitrary/location>/p44b init <path to p44build source directory of a product>
#
# Does the following
# - put a softlink called "p44b" pointing to the script itself into buildroot
# - creates a .p44build directory in the buildroot
# - remembers the product's p44build source directory in .p44build/p44b_src_dir
# - sets a softlink to the P44B_SRC dir
p44b_init() {
  local NEW_SRC_DIR="$1"
  if [[ $# -ne 1 ]]; then
    p44b_usage
    return 1
  fi
  if [ ! -d "${NEW_SRC_DIR}" ]; then
    echo "Error: '${NEW_SRC_DIR}' is not a directory"
    return 1
  fi
  # create state directory
  if [ -e "${P44B_STATE_DIR}" ]; then
    echo "Error: p44build apparently already initialized - if not, please cleanup first"
    return 1
  fi
  mkdir "${P44B_STATE_DIR}"
  # expand and save the directory
  pushd "${NEW_SRC_DIR}" >/dev/null
  P44B_SRC_DIR="$(pwd -P)"
  popd >/dev/null
  echo -n "${P44B_SRC_DIR}" > "${P44B_STATE_DIR}/p44b_src_dir"
  # find patches directory
  local PATCHES_DIR="${GLOBAL_PATCHES_DIR}"
  if [ ! -d "${P44B_SRC_DIR}/${PATCHES_DIR}" ]; then
    # fall back to old name
    PATCHES_DIR="lede-patches"
  fi
  # create soft link into buildroot to patch dir within sources
  if [ -f "${BUILDROOT}/patches" ]; then
    echo "Error: non-softlink '${BUILDROOT}/patches' already exists"
    return 1
  fi
  ln -sfh "${P44B_SRC_DIR}/${PATCHES_DIR}" "${BUILDROOT}/patches"
  # create convenience soft link to script itself in buildroot (but do not replace regular file, should there be one)
  if [ ! -f "${BUILDROOT}/${ALIAS}" ]; then
    ln -sfh "${SCRIPTFILE}" "${BUILDROOT}/${ALIAS}"
  fi
  echo "Successfully initialized p44build using directory: ${P44B_SRC_DIR}"
  return 0
}


# switch to a different p44b directory without re-patching the buildroot tree
# Is only possible if the two p44b directories share the same tree checkout SHA and same set of patches
#
# Usage: from a OpenWrt buildroot:
#    p44b switch <path to p44build source directory of another product using the same openwrt tree state>
#
# Does the following
# - put a softlink called "p44b" pointing to the script itself into buildroot
# - creates a .p44build directory in the buildroot
# - remembers the product's p44build source directory in .p44build/p44b_src_dir
# - sets a softlink to the P44B_SRC dir
p44b_switch() {
  local NEW_SRC_DIR="$1"
  if [[ $# -ne 1 ]]; then
    p44b_usage
    return 1
  fi
  if [ ! -d "${NEW_SRC_DIR}" ]; then
    echo "Error: '${NEW_SRC_DIR}' is not a directory"
    return 1
  fi
  # state directory must exist
  if [ ! -e "${P44B_STATE_DIR}" ]; then
    echo "p44build apparently not initialized, cannot switch - use 'init' first"
    return 1
  fi
  # expand new name
  pushd "${NEW_SRC_DIR}" >/dev/null
  NEW_SRC_DIR="$(pwd -P)"
  popd >/dev/null
  # check for same openwrt tree state
  local OLD_CHECKOUT=$(cat "${P44B_SRC_DIR}/buildroot_checkout")
  local NEW_CHECKOUT=$(cat "${NEW_SRC_DIR}/buildroot_checkout")
  if [[ "${OLD_CHECKOUT}" != "${NEW_CHECKOUT}" ]]; then
    echo "to-be-switched to directory is based on different buildroot checkout ('${NEW_CHECKOUT}' rather than '${OLD_CHECKOUT}') - use 'cleanup'/'init'"
    return 1
  fi
  # clean feeds from MacOS folder state files (there could be some in the patches, too)
  find ${BUILDROOT}/feeds -name .DS_Store -delete
  # check for same set of global patches (note: no check for legacy "lede-patches" here!)
  local OLD_PATCHES="${P44B_SRC_DIR}/${GLOBAL_PATCHES_DIR}"
  local NEW_PATCHES="${NEW_SRC_DIR}/${GLOBAL_PATCHES_DIR}"
  if ! diff "${OLD_PATCHES}" "${NEW_PATCHES}"; then
    echo "global set of patches is not equal, cannot switch - use 'cleanup'/'init'"
    return 1
  fi
  # make sure patches is a softlink
  if [ ! -h "${BUILDROOT}/patches" ]; then
    echo "Error: '${BUILDROOT}/patches' is not a softlink!"
    return 1
  fi
#   echo "patches dirs are equal: $OLD_PATCHES <-> $NEW_PATCHES"
#   echo "P44B_STATE_DIR = $P44B_STATE_DIR"
#   echo "NEW_SRC_DIR = $NEW_SRC_DIR"
#   echo "BUILDROOT = $BUILDROOT"
#   return 1
  # switch is possible
  # - un-target
  rm "${P44B_STATE_DIR}/target_id" 2>/dev/null
  rm "${BUILDROOT}/.config"  2>/dev/null
  # - save the new p44build directory
  echo -n "${NEW_SRC_DIR}" > "${P44B_STATE_DIR}/p44b_src_dir"
  # - set the soft link in buildroot to the new (but identical) patch dir
  ln -sfh "${NEW_SRC_DIR}/${GLOBAL_PATCHES_DIR}" "${BUILDROOT}/patches"
  echo "Successfully switched to new p44build directory: ${NEW_SRC_DIR}"
  return 0
}


# cleanup
p44b_cleanup() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  # Cleanup buildroot
  # - remove project specific config
  rm "${BUILDROOT}/.config" 2>/dev/null
  # - make sure patches are removed
  pushd "${BUILDROOT}" >/dev/null
  quilt pop -af
  # - remove the quilt working dir
  rm -rf "${BUILDROOT}/.pc"
  # - remove the softlink to the actual patches (but only softlink!)
  if [ -h "${BUILDROOT}/patches" ]; then
    rm "${BUILDROOT}/patches"
  fi
  # - remove the p44build state dir
  if [ -d "${P44B_STATE_DIR}" ]; then
    rm -rf "${P44B_STATE_DIR}"
  fi
  git status
  echo "# if status is not clean, you might want to use..."
  echo "git reset --hard"
  echo "# ...here to bring the tree back into clean state"
  popd >/dev/null
  # Note: do not remove the convenience link (will be updated in case another version of the script is used explicitly)
  return 0
}


# Prepare the tree
# - removes current patches
# - discards previous changes to the tree (if some are present, these will be stashed first)
# - checks out the buildroot commit as recorded in $P44B_SRC_DIR/buildroot_checkout
# - applies all buildroot patches
p44b_prepare() {
  # checkout the buildroot checkout
  if [ -f "${P44B_SRC_DIR}/buildroot_checkout" ]; then
    local BUILDROOT_CHECKOUT=$(cat "${P44B_SRC_DIR}/buildroot_checkout")
    pushd ${BUILDROOT} >/dev/null
    # check current checkout
    # - sha-wise
    if git rev-parse HEAD | grep -q ${BUILDROOT_CHECKOUT}; then
      # SHA matches
      echo "At correct SHA according to buildroot_checkout: ${BUILDROOT_CHECKOUT}"
    elif git log -n1 --oneline --decorate=short HEAD | grep -q ${BUILDROOT_CHECKOUT}; then
      # ref (branch, tag) matches
      echo "At correct ref according to buildroot_checkout: ${BUILDROOT_CHECKOUT}"
    else
      echo "Error: buildroot must be at ${BUILDROOT_CHECKOUT}"
      echo "might want to use: git checkout ${BUILDROOT_CHECKOUT}"
      exit 1
    fi
    # remove patches that might be there
    quilt pop -af
    # stash just in case, to avoid loosing data
    git stash
    # switch to correct buildroot state
    git reset --hard
    # apply the patches
    quilt push -a
    # clean feeds from MacOS folder state files
    find ${BUILDROOT}/feeds -name .DS_Store -delete
  else
    echo "Error: no buildroot_checkout (might want to use ${TRACKING_DIR}/buildroot_SHA or ${TRACKING_DIR}/buildroot_VERS)"
  fi
}


# Install those packages that were present at last save
# - if last save has created a install_packages.sh
p44b_instpkg() {
  # checkout the buildroot checkout
  if [ -f "${P44B_SRC_DIR}/${TRACKING_DIR}/install_packages.sh" ]; then
    bash ${P44B_SRC_DIR}/${TRACKING_DIR}/install_packages.sh
  else
    echo "Warning: no install_packages.sh found. You might want to install all packages instead with ./scripts/feeds install -a"
  fi
}



# Configure for a specific target
#
# Does the following
# - cleans tmp/
# - reindexes package feeds
# - copies target's diffconfig to .config and expands it with make defconfig
p44b_target() {
  if [[ $# -eq 0 ]]; then
    # list targets
    TARGETS="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig"*
    echo "Available targets:"
    for TG in ${TARGETS}; do
      echo "- ${TG##*/diffconfig-}"
    done
    return 0
  fi
  if [[ $# -ne 1 ]]; then
    p44b_usage
    return 1
  fi
  local NEW_TARGET_ID="$1"
  local DIFFCONFIG="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig-${NEW_TARGET_ID}"
  if [ ! -f "${DIFFCONFIG}" ]; then
    echo "Error: buildroot configuration file '${DIFFCONFIG}' not found"
    return 1
  fi
  # remember the target identifier
  TARGET_ID="${NEW_TARGET_ID}"
  echo -n "${TARGET_ID}" > "${P44B_STATE_DIR}/target_id"
  # update the package indices
  rm -rf ${BUILDROOT}/tmp 2>/dev/null
  pushd ${BUILDROOT} >/dev/null
  ./scripts/feeds update -i
  # copy the config and expand
  cp "${DIFFCONFIG}" "${BUILDROOT}/.config"
  make defconfig
  popd >/dev/null
  # show the status
  p44b_status
}






# restores the current build state
# - check only: SHA/version of OpenWrt
# - feeds.conf
# - SHA of feeds
# - SHA of specified packages
# - config for the current target
p44b_restore() {
  if [[ $# -lt 1 ]]; then
    p44b_usage
    return 1
  fi
  local BYSHA=0
  local APPLY=0
  local DO_ROOT=0
  local DO_FEEDS=0
  local DO_PACKAGES=0
  local DO_TARGET=0
  for OPT in $@ ; do
    case "$OPT" in
      "--sha") BYSHA=1;;
      "--apply") APPLY=1;;
      "root") DO_ROOT=1;;
      "feeds") DO_FEEDS=1;;
      "packages") DO_PACKAGES=1;;
      "target") DO_TARGET=1;;
      *) echo "unknown option $OPT"; return 1;;
    esac
  done
  if [[ -z "${TARGET_ID}" || -z "${P44B_SRC_DIR}" ]]; then
    echo "No target selected, cannot restore"
    return 1
  fi
  # diffconfig for current target
  local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
  # check if buildroot matches
  if [[ ${DO_ROOT} -ne 0 ]]; then
    pushd "${BUILDROOT}" >/dev/null
    local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
    if [[ ${BYSHA} -ne 0 ]]; then
      local CURRENT=$(git rev-parse HEAD)
      local SAVED=$(cat "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA")
    else
      local CURRENT=$(git rev-parse --abbrev-ref HEAD)
      local SAVED=$(cat "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_VERS")
    fi
    if [[ "${CURRENT}" != "${SAVED}" ]]; then
      echo "Buildroot originally saved from was at '${SAVED}', but is now at '${CURRENT}'"
      if [[ ${APPLY} -ne 0 ]]; then
        echo "**** NOT automatically changing this -> manually checkout the correct buildroot commit"
        return 1;
      fi
    fi
    echo "Buildroot state is correct: '${CURRENT}'"
    # current feeds.conf
    if ! cmp -s "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot" feeds.conf; then
      if [[ ${APPLY} -ne 0 ]]; then
        echo "feeds.conf has changed: moving original to feeds.conf_ORIG and putting new one in place"
        mv feeds.conf "feeds.conf_ORIG_$(date +%Y-%m-%d_%H:%M:%S)"
        cp "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot" feeds.conf
        echo "Updating and reindexing feeds"
        ./scripts/feeds update
      else
        echo "feeds.conf has changed:"
        diff "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot" feeds.conf
        echo ""
      fi
    else
      echo "feeds.conf is unchanged"
    fi
    popd >/dev/null
  fi
  # check feed states
  if [[ ${DO_FEEDS} -ne 0 ]]; then
    if [[ ${BYSHA} -ne 0 ]]; then
      local FEEDSTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_SHA"
    else
      local FEEDSTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_VERS"
    fi
    while IFS='' read -r line || [[ -n "$line" ]]; do
      if [[ "${line:0:1}" != "#" ]]; then
        local FEED="${line/ *}"
        local spec="${line:((${#FEED}+1))}"
        local URL="${spec%:*}"
        local SAVED="${spec:((${#URL}+1))}"
        pushd "${BUILDROOT}/feeds/${FEED}" >/dev/null
        if [[ ${BYSHA} -ne 0 ]]; then
          local CURRENT=$(git rev-parse HEAD)
        else
          local CURRENT=$(git rev-parse --abbrev-ref HEAD)
        fi
        popd >/dev/null
        if [[ "${CURRENT}" != "${SAVED}" ]]; then
          echo "***** feed ${FEED} should be at '${SAVED}' but is at '${CURRENT}'"
          if [[ ${APPLY} -ne 0 ]]; then
            "pushd ${BUILDROOT}/feeds/${FEED}; git stash; git checkout ${SAVED}; popd"
          else
            echo "pushd ${BUILDROOT}/feeds/${FEED}; git stash; git checkout ${SAVED}; popd"
          fi
        fi
      fi
    done < "${FEEDSTATES}"
  fi
  # modify makefiles of tracked packages to point to saved versions
  if [[ ${DO_PACKAGES} -ne 0 ]]; then
    if [[ ${BYSHA} -ne 0 ]]; then
      local PACKAGESTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
    else
      local PACKAGESTATES="${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
    fi
    while IFS='' read -r line || [[ -n "$line" ]]; do
      if [[ "${line:0:1}" != "#" ]]; then
        local pspec="${line/ *}"
        local FEED="${pspec/\/*}"
        local PNAME="${pspec:((${#FEED}+1))}"
        local spec="${line:((${#pspec}+1))}"
        local URL="${spec%:*}"
        local SAVED="${spec:((${#URL}+1))}"
        #echo "FEED=${FEED}, PNAME=${PNAME}, URL=${URL}, SAVED=${SAVED}"
        pushd "${BUILDROOT}/feeds/${FEED}/${PNAME}" >/dev/null
        local mfn="Makefile_ORIG_$(date +%Y-%m-%d_%H:%M:%S)"
        sed -E \
         -e "/PKG_SOURCE_URL:=/s|PKG_SOURCE_URL:=(.*)$|PKG_SOURCE_URL:=${URL}|" \
         -e "/PKG_SOURCE_VERSION:=/s|PKG_SOURCE_VERSION:=(.*)$|PKG_SOURCE_VERSION:=${SAVED}|" \
         Makefile > "/tmp/${mfn}"
        if cmp -s Makefile "/tmp/${mfn}"; then
          echo "${FEED}/${PNAME}: Makefile unchanged"
        else
          if [[ ${APPLY} -ne 0 ]]; then
            echo "${FEED}/${PNAME}: Makefile updated: PKG_SOURCE_URL='${URL}', PKG_SOURCE_VERSION='${SAVED}' - original: ${mfn}"
            mv Makefile "${mfn}"
            cp "/tmp/${mfn}" Makefile
          else
            echo "${FEED}/${PNAME}: Makefile needs to update: PKG_SOURCE_URL='${URL}', PKG_SOURCE_VERSION='${SAVED}'"
            diff Makefile "/tmp/${mfn}"
            echo ""
          fi
          rm "/tmp/${mfn}"
        fi
        popd >/dev/null
      fi
    done < "${PACKAGESTATES}"
  fi
  # target config re-apply
  if [[ ${DO_TARGET} -ne 0 ]]; then
    pushd "${BUILDROOT}" >/dev/null
    local cfn=".config_ORIG_$(date +%Y-%m-%d_%H:%M:%S)"
    if [[ ${APPLY} -ne 0 ]]; then
      echo "Re-applying target config, original version in ${cfn}"
      cp .config "${cfn}"
      p44b_target "${TARGET_ID}"
    else
      ./scripts/diffconfig.sh >"/tmp/diffconfig_${TARGET_ID}"
      echo "Target diffconfig has changed, should re-apply target settings:"
      diff "/tmp/diffconfig_${TARGET_ID}" "${CONFIGDIR}/diffconfig-${TARGET_ID}"
    fi
    popd >/dev/null
  fi
}



# saves the current build state
# - SHA of OpenWrt
# - feeds.conf as a reference
# - diffconfig for current target
# - SHA of feeds
# - SHA of specified packages
# - script for installing stuff from feeds (note: feeds.conf.default is made of OpenWrt+patches)
p44b_save() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [[ -z "${TARGET_ID}" || -z "${P44B_SRC_DIR}" ]]; then
    echo "No target selected, cannot save"
    return 1
  fi
  pushd ${BUILDROOT} >/dev/null
  # clean feeds from MacOS folder state files
  find ${BUILDROOT}/feeds -name .DS_Store -delete
  # SHA and branch of buildroot
  mkdir "${P44B_SRC_DIR}/${TRACKING_DIR}" 2>/dev/null
  local GITREV=$(git rev-parse HEAD)
  local GITVERS=$(git rev-parse --abbrev-ref HEAD)
  echo "openwrt buildroot: built from ${GITVERS} (SHA:${GITREV})"
  echo "${GITREV}" >"${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA"
  echo "${GITVERS}" >"${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_VERS"
  # current feeds.conf
  cp feeds.conf "${P44B_SRC_DIR}/${TRACKING_DIR}/feeds.conf-snapshot"
  # diffconfig for current target
  local CONFIGDIR="${P44B_SRC_DIR}/${CONFIGS_DIR}"
  ./scripts/diffconfig.sh >"${CONFIGDIR}/diffconfig-${TARGET_ID}"
  # complete config for reference purposes
  cp .config "${CONFIGDIR}/.config-${TARGET_ID}"
  popd >/dev/null
  # Capture installed packages from feeds (as a script that can be run to update feeds and install the packages)
  local INSTPKGS="${P44B_SRC_DIR}/${TRACKING_DIR}/install_packages.sh"
  echo "# Run this script to install all packages that were installed at the time of p44b save" >"${INSTPKGS}"
  FEEDS=$(find ${BUILDROOT}/package/feeds -type d -depth 1 -exec "echo" "{}" ";")
  for FEED in ${FEEDS}; do
    FEEDNAME=$(basename ${FEED})
    #echo "--- feed=${FEEDNAME} dir=${FEED}"
    pushd ${FEED} >/dev/null
    echo "./scripts/feeds update ${FEEDNAME}" >>"${INSTPKGS}"
    for INSTPDIR in *; do
      #echo "---   instpdir=${INSTPDIR}"
      local CMNT=""
      local INSTPNAMES=$(sed -E -n -e "/^Source-Makefile: +feeds\/${FEEDNAME}.*\/${INSTPDIR}\/Makefile/,/^Source-Makefile:/s/^Package: +([-a-zA-Z_]+)/\1/p" ${BUILDROOT}/feeds/${FEEDNAME}.index)
      for INSTPNAME in ${INSTPNAMES}; do
        #echo "---     instpname=${INSTPNAME}"
        echo "${CMNT}./scripts/feeds install -p ${FEEDNAME} ${INSTPNAME}" >>"${INSTPKGS}"
        # installing one of the packages from a makefile is sufficient, show but comment out the other packages made available as well
        CMNT="#"
      done
    done
    popd >/dev/null
  done
  # Capture state of feeds
  echo "# feed giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_VERS"
  echo "# feed giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_SHA"
  pushd "${BUILDROOT}/feeds" >/dev/null
  for FEED in !(*.*) ; do
    pushd "${FEED}" >/dev/null
    local GITURL=$(git remote show origin | sed -ne "/Fetch URL:/s/ *Fetch URL: //p")
    local GITREV=$(git rev-parse HEAD)
    local GITVERS=$(git rev-parse --abbrev-ref HEAD)
    echo "feed ${FEED}: origin at ${GITURL}:${GITVERS} (SHA:${GITREV})"
    echo "${FEED} ${GITURL}:${GITVERS}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_VERS"
    echo "${FEED} ${GITURL}:${GITREV}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/feeds_SHA"
    popd >/dev/null
  done
  popd >/dev/null
  # Track package source SHAs/versions
  read_config
  # go through tracked packages
  if [ ! -f "${P44B_SRC_DIR}/tracked_packages" ]; then
    echo "no tracked_packages file -> nothing to track"
    return 0
  fi
  local PACKAGES=$(cat "${P44B_SRC_DIR}/tracked_packages");
  # remove the previous trackings
  echo "# feed/package giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
  echo "# feed/package giturl:gitref" >"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
  local PUSHTAGS="${P44B_SRC_DIR}/${TRACKING_DIR}/pushtags.sh"
  echo "#!/bin/bash" >"${PUSHTAGS}"
  echo "pushd /tmp; rm -rf /tmp/p44b_temp; mkdir p44b_temp; cd p44b_temp" >>"${PUSHTAGS}"
  for PSPEC in ${PACKAGES}; do
    local FEEDNAME=${PSPEC%%/*}
    local PKGNAME=${PSPEC#*/}
    #echo "feed=$FEEDNAME pgk=$PKGNAME"
    local PKGDIR="${BUILDROOT}/feeds/${FEEDNAME}/${PKGNAME}"
    if [ ! -d "${PKGDIR}" ]; then
      echo "*** package not found for ${PSPEC}"
    else
      #echo "packagedir=$PKGDIR"
      # collect info from feed
      local PKG_NAME=$(sed -n -e "/^PKG_NAME:=/s/PKG_NAME:=//p" "${PKGDIR}/Makefile")
      local PKG_VERSION=$(sed -n -e "/^PKG_VERSION:=/s/PKG_VERSION:=//p" "${PKGDIR}/Makefile")
      local PKG_SOURCE_URL=$(sed -n -e "/^PKG_SOURCE_URL:=/s/PKG_SOURCE_URL:=//p" "${PKGDIR}/Makefile")
      local PKG_SOURCE_VERSION=$(sed -n -e "/^PKG_SOURCE_VERSION:=/s/PKG_SOURCE_VERSION:=//p" "${PKGDIR}/Makefile")
      local PKGNAMEVERS="${PKG_NAME}-${PKG_VERSION}"
      # build-dir as defined in makefile
      local PD=$(sed -n -e "/^PKG_BUILD_DIR:=/s/PKG_BUILD_DIR:=//p" "${PKGDIR}/Makefile")
      local PD=${PD//\$\(/\$\{}
      local PD=${PD//\)/\}}
      eval PKGBUILDDIR="$PD"
      #echo "PKG_NAME=$PKG_NAME, PKG_VERSION=$PKG_VERSION, PKG_SOURCE_VERSION=$PKG_SOURCE_VERSION, PD=$PD"
      #echo "package build dir: ${PKGBUILDDIR}"
      # collect info from build
      if [ ! -d "${PKGBUILDDIR}" ]; then
        echo "*** ${PKGNAMEVERS}: no build directory found"
      elif [ ! -e "${PKGBUILDDIR}/.gitdownload_url" ]; then
        echo "*** ${PKGNAMEVERS}: was not built with p44b checkout revision tracking"
      else
        # get info recorded during build
        local BUILDURL=$(cat "${PKGBUILDDIR}/.gitdownload_url")
        local BUILDREV=$(cat "${PKGBUILDDIR}/.gitdownload_rev")
        local BUILDVERS=$(cat "${PKGBUILDDIR}/.gitdownload_version")
        # get info from source repo
        if [[ "${BUILDREV}" != "${BUILDVERS}" && "${PKG_SOURCE_VERSION}" != "${BUILDREV}" ]]; then
          # vers is a ref (branch, tag) that can move -> get the SHA of that ref from the git source repo
          local R=$(git ls-remote "${PKG_SOURCE_URL}" "${PKG_SOURCE_VERSION}")
          local GITREV="${R%%[[:blank:]]*}"
          local GITVERS="${PKG_SOURCE_VERSION}"
        else
          # vers is a SHA that cannot move, so no need to check with source repo
          local GITREV="${BUILDREV}"
          local GITVERS=
        fi
        # consistency checks
        if [[ "${BUILDVERS}" != "${PKG_SOURCE_VERSION}" && "${BUILDREV}" != "${PKG_SOURCE_VERSION}" ]]; then
          echo "*** ${PKGNAMEVERS}: branch/commit recorded in build (${BUILDVERS}) differs from PKG_SOURCE_VERSION (${PKG_SOURCE_VERSION})"
        elif [[ "${PKG_SOURCE_URL}" != "${BUILDURL}" ]]; then
          echo "*** ${PKGNAMEVERS}: URL recorded in build (${BUILDURL}) differs from PKG_SOURCE_URL (${PKG_SOURCE_URL})"
        else
          # basic checks ok
          echo "package ${PKGNAMEVERS}: was built from ${BUILDURL}:${BUILDVERS} (SHA:${BUILDREV})"
          # check if we can trust the GITVERS branch name actually pointing to the built commit
          if [[ "${GITREV}" != "${BUILDREV}" ]]; then
            echo "*** ${PKGNAMEVERS}: Warning: SHA recorded in build (${BUILDREV}) differs from 'git ls-remote ... ${PKG_SOURCE_VERSION}' (${GITREV})"
            echo "# ${PSPEC}: build SHA differs from current 'git ls-remote ... ${PKG_SOURCE_VERSION}' (${GITREV}) - could be due to commits happening since build" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
            echo "# ${PSPEC}: WARNING: There is no branch/tag currently at ${BUILDREV}. We need to checkout whole repo" >>"${PUSHTAGS}"
            GITVERS=
          fi
          # - record fixed sha source
          echo "${PSPEC} ${BUILDURL}:${BUILDREV}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_SHA"
          # - record version/branch source
          echo "${PSPEC} ${BUILDURL}:${BUILDVERS}" >>"${P44B_SRC_DIR}/${TRACKING_DIR}/packages_VERS"
          # - create entry for tagging source repositories in tagging script
          if [[ -n "${GITVERS}" ]]; then
            echo "git clone --depth 1 --no-checkout --single-branch --branch ${BUILDVERS} ${PKG_SOURCE_URL} ${PKG_NAME}" >>"${PUSHTAGS}"
          else
            # we do not know which branch we need, just clone normally in full depth
            echo "git clone --no-checkout ${PKG_SOURCE_URL} ${PKG_NAME}" >>"${PUSHTAGS}"
          fi
          echo "pushd ${PKG_NAME}" >>"${PUSHTAGS}"
          echo "git tag -f ${VERSION_TAG} ${BUILDREV}" >>"${PUSHTAGS}"
          echo "git push -f origin ${VERSION_TAG}" >>"${PUSHTAGS}"
          echo "popd" >>"${PUSHTAGS}"
          chmod a+x "${PUSHTAGS}"
        fi
      fi
    fi
  done
  echo "popd" >>"${PUSHTAGS}"
}


# commit version as currently saved
p44b_commitversion() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    echo "Nothing saved, cannot commit"
    return 1
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    echo ".config does not contain version information"
    return 1
  fi
  # clean feeds from MacOS folder state files
  find ${BUILDROOT}/feeds -name .DS_Store -delete
  pushd "${P44B_SRC_DIR}" >/dev/null
  git add -A "${P44B_SRC_DIR}"
  git commit -m "${VERSION_TAG}"
  popd >/dev/null
  echo "# You might want to amend this commit with changes outside the ${ALIAS} directory"
}



# tag the current commit with a version tag
p44b_tagversion() {
  local DO_TAG_PKGS=0
  for OPT in $@ ; do
    case "$OPT" in
      "-p"|"--packages") DO_TAG_PKGS=1;;
      *) echo "unknown option $OPT"; return 1;;
    esac
  done
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    echo "Nothing saved, cannot tag"
    return 1
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    echo ".config does not contain version information"
    return 1
  else
    echo "Tagging: ${VERSION_TAG}"
    pushd "${P44B_SRC_DIR}" >/dev/null
    git tag -f "${VERSION_TAG}"
    popd >/dev/null
    # tag tracked packages?
    if [[ ${DO_TAG_PKGS} -ne 0 ]]; then
      echo "# Tagging tracked packages now:"
      ${P44B_SRC_DIR}/tracking/pushtags.sh
    fi
  fi
}


# push the current feed's master and the version tag to origin
p44b_pushversion() {
  if [[ $# -ne 1 ]]; then
    p44b_usage
    return 1
  fi
  local REMOTE="$1"
  if [[ -z "${P44B_SRC_DIR}" || ! -f "${P44B_SRC_DIR}/${TRACKING_DIR}/buildroot_SHA" ]]; then
    echo "Nothing saved, cannot push"
    return 1
  fi
  read_config
  if [[ -z "${VERSION_TAG}" ]]; then
    echo ".config does not contain version information"
    return 1
  else
    # detect branch
    pushd "${P44B_SRC_DIR}" >/dev/null
    local BRANCH=$(git rev-parse --abbrev-ref HEAD)
    echo "Pushing branch '${BRANCH}' and tag '${VERSION_TAG}' -> remote '${REMOTE}'"
    git push ${REMOTE} ${BRANCH}
    git push ${REMOTE} -f "${VERSION_TAG}"
    popd >/dev/null
  fi
}




# display status
p44b_status() {
  if [[ $# -ne 0 ]]; then
    p44b_usage
    return 1
  fi
  if [ ! -z "${P44B_SRC_DIR}" ]; then
    echo "Initialized with ${ALIAS} sources at '${P44B_SRC_DIR}'"
    echo "Current target  : '${TARGET_ID}'"
    read_config ".config" # current settings, not saved ones
    echo "Distribution    : ${CONFIG_VERSION_DIST}"
    echo "Product         : ${CONFIG_VERSION_PRODUCT}"
    echo "HW Revision     : ${CONFIG_VERSION_HWREV}"
    echo "Build dir       : ${BUILD_DIR}"
    echo "staging_dir     : ${STAGING_ROOT}"
    echo "toolchain       : ${TOOLCHAIN_ROOT}"
    echo "target host     : ${TARGET_HOST}"
    echo "Current version : ${CONFIG_VERSION_NUMBER}"
    echo "Current feed    : ${CONFIG_P44_FEED_NAME}"
    read_config # saved settings
    echo "Saved Version   : ${CONFIG_VERSION_NUMBER}"
    echo "Saved feed      : ${CONFIG_P44_FEED_NAME}"
  else
    echo "This tree is not initialized for ${ALIAS} yet"
  fi
}


p44b_build() {
  local BUILDCMD="${P44B_SRC_DIR}/${SCRIPTS_DIR}/build.sh"
  if [ ! -f "${BUILDCMD}" ]; then
    echo "no build.sh script in ${ALIAS} folder -> just using make"
    BUILDCMD="make"
  fi
  # run build script/make
  echo "===== starting build at $(date +%Y-%m-%d_%H:%M:%S)"
  $BUILDCMD "$@"
  echo "===== finished build at $(date +%Y-%m-%d_%H:%M:%S)"
}


p44b_package() {
  local PKGSCRIPT="${P44B_SRC_DIR}/${SCRIPTS_DIR}/package.sh"
  if [ ! -f "${PKGSCRIPT}" ]; then
    echo "no package.sh script in ${ALIAS} script folder"
    return 1
  fi
  # run it
  $PKGSCRIPT "$@"
}


p44b_deploy() {
  local DPLSCRIPT="${P44B_SRC_DIR}/${SCRIPTS_DIR}/deploy.sh"
  if [ ! -f "${DPLSCRIPT}" ]; then
    echo "no deploy.sh script in ${ALIAS} script folder"
    return 1
  fi
  # run it
  $DPLSCRIPT "$@"
}



p44b_buildtargets() {
  local DO_TAG=0
  local DO_PUSH=0
  local DO_DEPLOY=0
  local TARGETS
  for ARG in $@ ; do
    case "$ARG" in
      "-t"|"--tag") DO_TAG=1;;
      "-d"|"--deploy") DO_DEPLOY=1;;
      "-p"|"--push") DO_PUSH=1;;
      "all") local TGS="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig"*; for TG in ${TGS}; do TARGETS="$TARGETS ${TG##*/diffconfig-}"; done;;
      *) TARGETS="$TARGETS $ARG";;
    esac
  done
  # sanity check
  if [ -z "${TARGETS}" ]; then
    # list targets
    TARGETS="${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig"*
    echo "Available targets (specify 'ALL' to build all):"
    for TG in ${TARGETS}; do
      echo "- ${TG##*/diffconfig-}"
    done
    return 0
  fi
  # check for "ALL"
  if [[ "${TARGETS}" == " ALL" ]]; then
    TARGETS=
    for TG in "${P44B_SRC_DIR}/${CONFIGS_DIR}/diffconfig"*; do
      TARGETS="$TARGETS ${TG##*/diffconfig-}"
    done
  fi
  # source preparation script, if any
  local PREPINC="${P44B_SRC_DIR}/${SCRIPTS_DIR}/buildprep.inc"
  if [ -x "${PREPINC}" ]; then
    # source it to set ennvironment vars etc.
    source "${PREPINC}"
  fi
  # now do targets
  for TARGET in $TARGETS; do
    echo
    echo "======= Starting target '${TARGET}' at $(date +%Y-%m-%d_%H:%M:%S)"
    p44b_target "${TARGET}"
    p44b_build ${P44B_BUILD_ARGS}
    p44b_package ${P44B_PACKAGE_ARGS}
    p44b_save
    if [[ ${DO_DEPLOY} -ne 0 ]]; then
      p44b_deploy ${P44B_DEPLOY_ARGS}
    fi
    if [[ ${DO_TAG} -ne 0 ]]; then
      p44b_commitversion
      p44b_tagversion ${P44B_TAGVERSION_ARGS}
    fi
    if [[ ${DO_PUSH} -ne 0 ]]; then
      p44b_pushversion ${P44B_PUSHVERSION_ARGS}
    fi
    echo "======= Finished target '${TARGET}' at $(date +%Y-%m-%d_%H:%M:%S)"
    echo
  done
}



p44b_run() {
  if [[ $# -lt 1 ]]; then
    p44b_usage
    return 1
  fi
  local SCRIPT="${P44B_SRC_DIR}/${SCRIPTS_DIR}/$1"
  if [ ! -f "${SCRIPT}" ]; then
    echo "no script '$1' in ${ALIAS} script folder"
    return 1
  fi
  shift 1
  # run it
  $SCRIPT "$@"
}


p44b_send() {
  if [[ -z "${TARGET_HOST}" ]]; then
    echo "Need to define TARGET_HOST shell variable"
    return 1
  fi
  local SRCFILE=""
  local SRCSUFFIX=""
  local DO_STRIP=0
  read_config ".config" # current settings, not saved ones
  while [[ "${1:0:1}" == "-" ]]; do
    case "$1" in
#      "-p"|"--package") SRCFILE="bin/packages/mipsel_24kc/plan44/", SRCSUFFIX='*.ipk';shift 1;;
      "-e"|"--executable") SRCFILE="${STAGING_ROOT}/usr/bin/" ;shift 1;;
      "-d"|"--debuggable") SRCFILE="${STAGING_ROOT}/usr/bin/" ; DO_STRIP=1; shift 1;;
      *) echo "unknown option $1";return 1;;
    esac
  done
  if [[ $# -eq 0 ]]; then
    # default to current image
    if [[ -z ${SRCFILE} ]]; then
      read_config ".config" # current settings, not saved ones
      local SRCIMGS=$(ls -1t ${BUILDROOT}/bin/targets/${CONFIG_TARGET_BOARD}/${CONFIG_TARGET_SUBTARGET}/${IMG_DIST_NAME_LC}-${CONFIG_VERSION_NUMBER}*-${CONFIG_TARGET_BOARD}-${CONFIG_TARGET_SUBTARGET}-${CONFIG_TARGET_PROFILE##DEVICE_}-*);
      set -- $SRCIMGS
    fi
    local SRCFILE=$1
    local TARGPATH='/tmp'
  elif [[ $# -eq 1 ]]; then
    SRCFILE="${SRCFILE}$1"
    local TARGPATH='/tmp'
  elif [[ $# -eq 2 ]]; then
    SRCFILE="${SRCFILE}$1"
    local TARGPATH=$2
  else
    p44b_usage
    return 1
  fi
  if [[ ${DO_STRIP} -ne 0 ]]; then
    echo "# Stripping symbols from ${SRCFILE}"
    "${TOOLCHAIN_ROOT}/binutils/binutils/strip-new" -o /tmp/debugtarget "${SRCFILE}"
    SRCFILE="/tmp/debugtarget"
  fi
  echo "# Sending: ${SRCFILE} to ${TARGET_HOST}:${TARGPATH}"
  echo "scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no ${SRCFILE} root@${TARGET_HOST}:${TARGPATH}"
  scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "${SRCFILE}" "root@${TARGET_HOST}:${TARGPATH}"
  echo "...done"
}


p44b_debug() {
  if [[ $# -eq 0 ]]; then
    echo "need to specify executable"
    return 1
  fi
  local EXECNAME=$1
  p44b_send -d ${EXECNAME}
  local EXECS=$(ls -1t ${BUILDROOT}/build_dir/${TARGETID}/${EXECNAME}-*/${EXECNAME})
  set -- $EXECS
  local EXEC=$1
  echo "# Debugging: ${EXEC} - paste next line into gdb"
  echo "set remote exec-file /tmp/debugtarget"
  ${BUILDROOT}/scripts/remote-gdb ${TARGET_HOST}:9000 ${EXEC}
  echo "# done debugging ${EXEC}"
}




p44b_get() {
  if [[ -z "${TARGET_HOST}" ]]; then
    echo "Need to define TARGET_HOST shell variable"
    return 1
  fi
  if [[ $# -lt 1 || $# -gt 2 ]]; then
    p44b_usage
    return 1
  fi
  SRCFILE="$1"
  if [[ $# -eq 1 ]]; then
    local DESTDIR="/tmp"
  else
    local DESTDIR="$2"
  fi
  if [[ ! -d "${DESTDIR}" ]]; then
    echo "${DESTDIR} is not a directory"
    return 1
  fi
  echo "# Getting: ${TARGET_HOST}:${SRCFILE} to ${DESTDIR}"
  echo "scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@${TARGET_HOST}:${SRCFILE} ${DESTDIR}"
  scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no "root@${TARGET_HOST}:${SRCFILE}" "${DESTDIR}"
  echo "...done"
}



p44b_login() {
  if [[ $# -eq 0 ]]; then
    if [[ -z "${TARGET_HOST}" ]]; then
      echo "Specify host as parameter or define TARGET_HOST shell variable"
      return 1
    fi
    local HOST="${TARGET_HOST}"
  elif [[ $# -eq 1 ]]; then
    local HOST="$1"
  else
    p44b_usage
    return 1
  fi
  echo "# connecting to ${HOST}:"
  echo "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@${TARGET_HOST}"
  ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@${TARGET_HOST}
}



p44b_test() {
  echo "dummy"
}


# usage
p44b_usage() {
  echo "usage: ${SCRIPTNAME} status                            - show status"
  echo "   or: ${SCRIPTNAME} cleanup                           - clean up buildroot"
  echo "   or: ${SCRIPTNAME} init <srcdir>                     - initialize buildroot from a ${ALIAS} source directory"
  echo "   or: ${SCRIPTNAME} switch <srcdir>                   - (try to) switch to a ${ALIAS} source directory w/o changing buildroot (possible if patches are equal)"
  echo "   or: ${SCRIPTNAME} prepare                           - prepare (patch) tree from ${ALIAS} info"
  echo "   or: ${SCRIPTNAME} instpkg                           - install those packages from feeds that were present at last ${ALIAS} save"
  echo "   or: ${SCRIPTNAME} target [<target>]                 - list targets or switch to specified target configuration"
  echo "   or: ${SCRIPTNAME} build [<args>...]                 - call build.sh script if existing, otherwise just call make, with optional args"
  echo "   or: ${SCRIPTNAME} package [<args>...]               - call package.sh script with optional args"
  echo "   or: ${SCRIPTNAME} deploy [<args>...]                - call deploy.sh script with optional args"
  echo "   or: ${SCRIPTNAME} save                              - save current build's SHAs of buildroot and tracked packages"
  echo "   or: ${SCRIPTNAME} restore [--sha][--apply] (root|feeds|packages)  - restore saved state, --apply to actually modify, --sha to use sha, not branch names"
  echo "   or: ${SCRIPTNAME} send [-e|-d] [<file> [<remote path>]]  - send [[-d:stripped]-e:executable] <file> (default: built image for current target) to \$TARGET_HOST via scp (default path: /tmp)"
  echo "   or: ${SCRIPTNAME} debug <package>                   - send <package>'s executable (stripped) and start gdb session for it"
  echo "   or: ${SCRIPTNAME} get <remote file> [<dir>]         - get <remote file> to local <dir> (default: /tmp) from \$TARGET_HOST via scp"
  echo "   or: ${SCRIPTNAME} login [<host>]                    - connect to specified host or TARGET_HOST via ssh w/o identity checking"
  echo "   or: ${SCRIPTNAME} commitversion                     - commit the currently saved version to the feed the ${ALIAS} source directory is in"
  echo "   or: ${SCRIPTNAME} tagversion [-p|--packages]        - tag the currently saved and committed version (-p: including tracked packages)"
  echo "   or: ${SCRIPTNAME} pushversion <remote>              - push the currently checked out branch and the version tag to remote"
  echo "   or: ${SCRIPTNAME} buildtargets [opts] <targets>...  - switch to, build, package, save <targets>; [--deploy] with deploy, [--tag] with commit+tag, [--push] with push"
  echo "   or: ${SCRIPTNAME} run <script> [<args>...]          - run script from ${ALIAS} scripts folder"
}


# main
if [[ $# -lt 1 ]]; then
  p44b_usage
  exit 1
fi
COMMAND="$1"
shift 1
case ${COMMAND} in
  "status")
    p44b_status "$@"
    ;;
  "init")
    p44b_init "$@"
    ;;
  "switch")
    p44b_switch "$@"
    ;;
  "cleanup")
    p44b_cleanup "$@"
    ;;
  "prepare")
    p44b_prepare "$@"
    ;;
  "instpkg")
    p44b_instpkg "$@"
    ;;
  "target")
    p44b_target "$@"
    ;;
  "build")
    p44b_build "$@"
    ;;
  "package")
    p44b_package "$@"
    ;;
  "deploy")
    p44b_deploy "$@"
    ;;
  "send")
    p44b_send "$@"
    ;;
  "debug")
    p44b_debug "$@"
    ;;
  "get")
    p44b_get "$@"
    ;;
  "login")
    p44b_login "$@"
    ;;
  "save")
    p44b_save "$@"
    ;;
  "restore")
    p44b_restore "$@"
    ;;
  "commitversion")
    p44b_commitversion "$@"
    ;;
  "tagversion")
    p44b_tagversion "$@"
    ;;
  "pushversion")
    p44b_pushversion "$@"
    ;;
  "buildtargets")
    p44b_buildtargets "$@"
    ;;
  "run")
    p44b_run "$@"
    ;;
  "test")
    p44b_test "$@"
    ;;
  *)
    echo "Unknown subcommand '${COMMAND}'"
    p44b_usage
    exit 1
    ;;
esac
